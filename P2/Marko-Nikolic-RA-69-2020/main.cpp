// Marko Nikolic
// RA 69/2020

#define _CRT_SECURE_NO_WARNINGS

#include <iostream>
#include <fstream>
#include <sstream>

#define _USE_MATH_DEFINES
#include <cmath>

#include <GL/glew.h>
#include <GLFW/glfw3.h>

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include "shader.hpp"
#include "model.hpp"

const unsigned int wWidth = 800;
const unsigned int wHeight = 600;

static void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mode);
static void generateCylinderVertices(float radius, float height, int sides, std::vector<float>& vertices);
static void generateConeVertices(float radius, float height, int sides, std::vector<float>& vertices);
static void generateMeshVertices(std::vector<float>& vertices);
static unsigned loadImageToTexture(const char* filePath);

glm::mat4 projectionP = glm::perspective(glm::radians(90.0f), (float)wWidth / (float)wHeight, 0.1f, 100.0f);
glm::mat4 projectionO = glm::ortho(-1.0f, 1.0f, -1.0f, 1.0f, 0.1f, 100.0f);
glm::mat4 projection = projectionP;

glm::mat4 view = glm::mat4(1.0f);
float zoomSpeed = 0.001f;
glm::vec3 cameraPosition = glm::vec3(0.0f, 0.0f, 2.0f);

bool resetAntenna = false;

int switchRegime = 0;
float amfmSwitchTranslation = 0.0f;

int switchPower = 0;
float onoffSwitchTranslation = 0.0f;

int main()
{
    if(!glfwInit())
    {
        std::cout << "GLFW fail!\n" << std::endl;
        return -1;
    }

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    GLFWwindow* window = glfwCreateWindow(wWidth, wHeight, "LearnOpenGL", NULL, NULL);
    if (window == NULL)
    {
        std::cout << "Window fail!\n" << std::endl;
        glfwTerminate();
        return -2;
    }
    glfwMakeContextCurrent(window);
    glfwSetKeyCallback(window, keyCallback);

    if (glewInit() !=GLEW_OK)
    {
        std::cout << "GLEW fail! :(\n" << std::endl;
        return -3;
    }

    glEnable(GL_BLEND);
    glBlendFuncSeparate(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_ONE, GL_ZERO);

    const unsigned int VAOVBOCount = 23;
    unsigned int VAO[VAOVBOCount];
    glGenVertexArrays(VAOVBOCount, VAO);
    unsigned int VBO[VAOVBOCount];
    glGenBuffers(VAOVBOCount, VBO);
    unsigned int stride;

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++ VARIABLES AND BUFFERS +++++++++++++++++++++++++++++++++++++++++++++++++
    
    // RADIO
    float vertices1[] =
    {
        //X     Y      Z       NX    NY     NZ
        0.7f, -0.4f, -0.2f,  0.0f,  0.0f, -1.0f,
        -0.7f, -0.4f, -0.2f,  0.0f,  0.0f, -1.0f,
        -0.7f, 0.5f, -0.2f,  0.0f,  0.0f, -1.0f,
        -0.7f, 0.5f, -0.2f,  0.0f,  0.0f, -1.0f,
         0.7f,  0.5f, -0.2f,  0.0f,  0.0f, -1.0f,
        0.7f, -0.4f, -0.2f,  0.0f,  0.0f, -1.0f,

        -0.7f, -0.4f, -0.2f, -1.0f,  0.0f,  0.0f,
        -0.7f, -0.4f,  0.4f, -1.0f,  0.0f,  0.0f,
        -0.7f, 0.5f,  0.4f, -1.0f,  0.0f,  0.0f,
        -0.7f, 0.5f,  0.4f, -1.0f,  0.0f,  0.0f,
        -0.7f, 0.5f, -0.2f, -1.0f,  0.0f,  0.0f,
        -0.7f, -0.4f, -0.2f, -1.0f,  0.0f,  0.0f,

         0.7f, -0.4f,  0.4f,  1.0f,  0.0f,  0.0f,
         0.7f, -0.4f, -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.0f, -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.0f, -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.0f,  0.4f,  1.0f,  0.0f,  0.0f,
         0.7f, -0.4f,  0.4f,  1.0f,  0.0f,  0.0f,

         0.7f,  0.0f,  0.4f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.0f,  0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f,  0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f,  0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f,  0.4f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.0f,  0.4f,  1.0f,  0.0f,  0.0f,
         
         0.7f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.0f,  -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f,  -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f,  -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f,  0.0f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.0f,  0.0f,  1.0f,  0.0f,  0.0f,

         0.7f,  0.1f,  0.4f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f, -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.5f, -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.5f, -0.2f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.5f,  0.4f,  1.0f,  0.0f,  0.0f,
         0.7f,  0.1f,  0.4f,  1.0f,  0.0f,  0.0f,

        -0.7f, -0.4f, -0.2f,  0.0f, -1.0f,  0.0f,
         0.7f, -0.4f, -0.2f,  0.0f, -1.0f,  0.0f,
         0.7f, -0.4f,  0.4f,  0.0f, -1.0f,  0.0f,
         0.7f, -0.4f,  0.4f,  0.0f, -1.0f,  0.0f,
        -0.7f, -0.4f,  0.4f,  0.0f, -1.0f,  0.0f,
        -0.7f, -0.4f, -0.2f,  0.0f, -1.0f,  0.0f,
         
        -0.7f, 0.5f,  0.4f,  0.0f,  1.0f,  0.0f,
        0.7f, 0.5f,  0.4f,  0.0f,  1.0f,  0.0f,
        0.7f, 0.5f, -0.2f,  0.0f,  1.0f,  0.0f,
        0.7f, 0.5f, -0.2f,  0.0f,  1.0f,  0.0f,
        -0.7f, 0.5f, -0.2f,  0.0f,  1.0f,  0.0f,
        -0.7f, 0.5f,  0.4f,  0.0f,  1.0f,  0.0f,

        -0.7f,  0.45f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f,  0.45f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f,  0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f, 0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f, 0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f,  0.45f, 0.4f,  0.0f,  0.0f, 1.0f,

        -0.7f,  0.35f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.4f,  0.35f, 0.4f,  0.0f,  0.0f, 1.0f,
         -0.4f,  0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
         -0.4f, 0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f, 0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f,  0.35f, 0.4f,  0.0f,  0.0f, 1.0f,

        0.6f,  0.35f, 0.4f,  0.0f,  0.0f, 1.0f,
        0.7f,  0.35f, 0.4f,  0.0f,  0.0f, 1.0f,
        0.7f,  0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
        0.7f, 0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
        0.6f, 0.5f, 0.4f,  0.0f,  0.0f, 1.0f,
        0.6f,  0.35f, 0.4f,  0.0f,  0.0f, 1.0f,

        -0.7f,  0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f,  0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f,  0.35f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f, 0.35f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f, 0.35f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f,  0.25f, 0.4f,  0.0f,  0.0f, 1.0f,

        -0.7f,  -0.4f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f,  -0.4f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f,  -0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
         0.7f, -0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f, -0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f,  -0.4f, 0.4f,  0.0f,  0.0f, 1.0f,

        -0.7f,  -0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.6f, -0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.6f,  0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.6f, 0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f, 0.25f, 0.4f,  0.0f,  0.0f, 1.0f,
        -0.7f, -0.25f, 0.4f,  0.0f,  0.0f, 1.0f,

        -0.1f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.0f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.0f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.0f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,

        0.6f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.6f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.6f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,

        -0.1f, 0.2f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, 0.2f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, 0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, 0.2f, 0.4f, 0.0f, 0.0f, 1.0f,

        -0.1f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, -0.2f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, -0.2f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, -0.2f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, -0.25f, 0.4f, 0.0f, 0.0f, 1.0f,

        -0.1f, -0.1f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, -0.1f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, 0.1f, 0.4f, 0.0f, 0.0f, 1.0f,
        0.7f, 0.1f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, 0.1f, 0.4f, 0.0f, 0.0f, 1.0f,
        -0.1f, -0.1f, 0.4f, 0.0f, 0.0f, 1.0f,

        -0.725f, 0.425f, 0.1125f, 0.0f, 0.0f, 1.0f,
        -0.7f, 0.425f, 0.1125f, 0.0f, 0.0f, 1.0f,
        -0.7f, 0.45, 0.1125f, 0.0f, 0.0f, 1.0f,
        -0.7f, 0.45, 0.1125f, 0.0f, 0.0f, 1.0f,
        -0.725f, 0.45, 0.1125f, 0.0f, 0.0f, 1.0f,
        -0.725f, 0.425f, 0.1125f, 0.0f, 0.0f, 1.0f,

        -0.7f, 0.425f, 0.0875f, 0.0f, 0.0f, -1.0f,
        -0.725f, 0.425f, 0.0875f, 0.0f, 0.0f, -1.0f,
        -0.725f, 0.45, 0.0875f, 0.0f, 0.0f, -1.0f,
        -0.725f, 0.45, 0.0875f, 0.0f, 0.0f, -1.0f,
        -0.7f, 0.45, 0.0875f, 0.0f, 0.0f, -1.0f,
        -0.7f, 0.425f, 0.0875f, 0.0f, 0.0f, -1.0f,

        -0.725f, 0.425f, 0.0875f, -1.0f, 0.0f, 0.0f,
        -0.725f, 0.425f, 0.1125f, -1.0f, 0.0f, 0.0f,
        -0.725f, 0.45, 0.1125f, -1.0f, 0.0f, 0.0f,
        -0.725f, 0.45, 0.1125f, -1.0f, 0.0f, 0.0f,
        -0.725f, 0.45, 0.0875f, -1.0f, 0.0f, 0.0f,
        -0.725f, 0.425f, 0.0875f, -1.0f, 0.0f, 0.0f,

        -0.725f, 0.45, 0.1125f, 0.0f, 1.0f, 0.0f,
        -0.7f, 0.45, 0.1125f, 0.0f, 1.0f, 0.0f,
        -0.7f, 0.45, 0.0875f, 0.0f, 1.0f, 0.0f,
        -0.7f, 0.45, 0.0875f, 0.0f, 1.0f, 0.0f,
        -0.725f, 0.45, 0.0875f, 0.0f, 1.0f, 0.0f,
        -0.725f, 0.45, 0.1125f, 0.0f, 1.0f, 0.0f,

        -0.725f, 0.425f, 0.0875f, 0.0f, -1.0f, 0.0f,
        -0.7f, 0.425f, 0.0875f, 0.0f, -1.0f, 0.0f,
        -0.7f, 0.425f, 0.1125f, 0.0f, -1.0f, 0.0f,
        -0.7f, 0.425f, 0.1125f, 0.0f, -1.0f, 0.0f,
        -0.725f, 0.425f, 0.1125f, 0.0f, -1.0f, 0.0f,
        -0.725f, 0.425f, 0.0875f, 0.0f, -1.0f, 0.0f,
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[0]);
    glBindVertexArray(VAO[0]);
    glGenBuffers(1, &VBO[0]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[0]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices1), vertices1, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    // SPEAKER BOX
    float vertices2[] =
    {
        //X     Y      Z       NX    NY     NZ
         -0.6f, -0.25f,  0.4f,  1.0f,  0.0f,  0.0f,
         -0.6f, -0.25f,  0.305f,  1.0f,  0.0f,  0.0f,
         -0.6f,  0.25f,  0.305f,  1.0f,  0.0f,  0.0f,
         -0.6f,  0.25f,  0.305f,  1.0f,  0.0f,  0.0f,
         -0.6f,  0.25f,  0.4f,  1.0f,  0.0f,  0.0f,
         -0.6f, -0.25f,  0.4f,  1.0f,  0.0f,  0.0f,

         -0.1f, -0.25f,  0.305f,  -1.0f,  0.0f,  0.0f,
         -0.1f, -0.25f,  0.4f,  -1.0f,  0.0f,  0.0f,
          -0.1f,  0.25f,  0.4f,  -1.0f,  0.0f,  0.0f,
          -0.1f,  0.25f,  0.4f,  -1.0f,  0.0f,  0.0f,
          -0.1f,  0.25f,  0.305f,  -1.0f,  0.0f,  0.0f,
         -0.1f, -0.25f,  0.305f,  -1.0f,  0.0f,  0.0f,

         -0.6f, -0.25f,  0.4f,  0.0f,  1.0f,  0.0f,
         -0.1f, -0.25f,  0.4f,  0.0f,  1.0f,  0.0f,
         -0.1f, -0.25f,  0.305f,  0.0f,  1.0f,  0.0f,
         -0.1f, -0.25f,  0.305f,  0.0f,  1.0f,  0.0f,
         -0.6f, -0.25f,  0.305f,  0.0f,  1.0f,  0.0f,
         -0.6f, -0.25f,  0.4f,  0.0f,  1.0f,  0.0f,

         -0.6f,  0.25f,  0.305f,  0.0f, -1.0f,  0.0f,
         -0.1f,  0.25f,  0.305f,  0.0f, -1.0f,  0.0f,
         -0.1f,  0.25f,  0.4f,  0.0f, -1.0f,  0.0f,
         -0.1f,  0.25f,  0.4f,  0.0f, -1.0f,  0.0f,
         -0.6f,  0.25f,  0.4f,  0.0f, -1.0f,  0.0f,
         -0.6f,  0.25f,  0.305f,  0.0f, -1.0f,  0.0f,

         -0.6f,  -0.25f,  0.305f,  0.0f,  0.0f,  1.0f,
         -0.1f,  -0.25f,  0.305f,  0.0f,  0.0f,  1.0f,
         -0.1f,  0.25f,  0.305f,  0.0f,  0.0f,  1.0f,
         -0.1f,  0.25f,  0.305f,  0.0f,  0.0f,  1.0f,
         -0.6f,  0.25f,  0.305f,  0.0f,  0.0f,  1.0f,
         -0.6f, -0.25f,  0.305f,  0.0f,  0.0f,  1.0f,
         // ---------------------------------------------
          0.0f,  0.1f,  0.4f,  1.0f,  0.0f,  0.0f,
          0.0f,  0.1f,  0.3f,  1.0f,  0.0f,  0.0f,
          0.0f,  0.2f,  0.3f,  1.0f,  0.0f,  0.0f,
          0.0f,  0.2f,  0.3f,  1.0f,  0.0f,  0.0f,
          0.0f,  0.2f,  0.4f,  1.0f,  0.0f,  0.0f,
          0.0f,  0.1f,  0.4f,  1.0f,  0.0f,  0.0f,

          0.6f,  0.1f,  0.3f,  -1.0f,  0.0f,  0.0f,
          0.6f,  0.1f,  0.4f,  -1.0f,  0.0f,  0.0f,
          0.6f,  0.2f,  0.4f,  -1.0f,  0.0f,  0.0f,
          0.6f,  0.2f,  0.4f,  -1.0f,  0.0f,  0.0f,
          0.6f,  0.2f,  0.3f,  -1.0f,  0.0f,  0.0f,
          0.6f,  0.1f,  0.3f,  -1.0f,  0.0f,  0.0f,

          0.0f,  0.1f,  0.4f,  0.0f,  1.0f,  0.0f,
          0.6f,  0.1f,  0.4f,  0.0f,  1.0f,  0.0f,
          0.6f,  0.1f,  0.3f,  0.0f,  1.0f,  0.0f,
          0.6f,  0.1f,  0.3f,  0.0f,  1.0f,  0.0f,
          0.0f,  0.1f,  0.3f,  0.0f,  1.0f,  0.0f,
          0.0f,  0.1f,  0.4f,  0.0f,  1.0f,  0.0f,

          0.0f,  0.2f,  0.3f,  0.0f,  -1.0f,  0.0f,
          0.6f,  0.2f,  0.3f,  0.0f,  -1.0f,  0.0f,
          0.6f,  0.2f,  0.4f,  0.0f,  -1.0f,  0.0f,
          0.6f,  0.2f,  0.4f,  0.0f,  -1.0f,  0.0f,
          0.0f,  0.2f,  0.4f,  0.0f,  -1.0f,  0.0f,
          0.0f,  0.2f,  0.3f,  0.0f,  -1.0f,  0.0f,

          0.0f,  0.1f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.6f,  0.1f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.6f,  0.2f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.6f,  0.2f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.0f,  0.2f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.0f,  0.1f,  0.3f,  0.0f,  0.0f,  1.0f,
          // ---------------------------------------------
          0.0f,  -0.2f,  0.4f,  1.0f,  0.0f,  0.0f,
          0.0f,  -0.2f,  0.3f,  1.0f,  0.0f,  0.0f,
          0.0f,  -0.1f,  0.3f,  1.0f,  0.0f,  0.0f,
          0.0f,  -0.1f,  0.3f,  1.0f,  0.0f,  0.0f,
          0.0f,  -0.1f,  0.4f,  1.0f,  0.0f,  0.0f,
          0.0f,  -0.2f,  0.4f,  1.0f,  0.0f,  0.0f,

          0.6f,  -0.2f,  0.3f,  -1.0f,  0.0f,  0.0f,
          0.6f,  -0.2f,  0.4f,  -1.0f,  0.0f,  0.0f,
          0.6f,  -0.1f,  0.4f,  -1.0f,  0.0f,  0.0f,
          0.6f,  -0.1f,  0.4f,  -1.0f,  0.0f,  0.0f,
          0.6f,  -0.1f,  0.3f,  -1.0f,  0.0f,  0.0f,
          0.6f,  -0.2f,  0.3f,  -1.0f,  0.0f,  0.0f,

          0.0f,  -0.2f,  0.4f,  0.0f,  1.0f,  0.0f,
          0.6f,  -0.2f,  0.4f,  0.0f,  1.0f,  0.0f,
          0.6f,  -0.2f,  0.3f,  0.0f,  1.0f,  0.0f,
          0.6f,  -0.2f,  0.3f,  0.0f,  1.0f,  0.0f,
          0.0f,  -0.2f,  0.3f,  0.0f,  1.0f,  0.0f,
          0.0f,  -0.2f,  0.4f,  0.0f,  1.0f,  0.0f,

          0.0f, -0.1f,  0.3f,  0.0f,  -1.0f,  0.0f,
          0.6f, -0.1f,  0.3f,  0.0f,  -1.0f,  0.0f,
          0.6f, -0.1f,  0.4f,  0.0f,  -1.0f,  0.0f,
          0.6f, -0.1f,  0.4f,  0.0f,  -1.0f,  0.0f,
          0.0f, -0.1f,  0.4f,  0.0f,  -1.0f,  0.0f,
          0.0f, -0.1f,  0.3f,  0.0f,  -1.0f,  0.0f,

          0.0f, -0.2f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.6f, -0.2f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.6f, -0.1f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.6f, -0.1f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.0f, -0.1f,  0.3f,  0.0f,  0.0f,  1.0f,
          0.0f, -0.2f,  0.3f,  0.0f,  0.0f,  1.0f,
          // ---------------------------------------------
          0.6f,  0.0f, 0.2f, 1.0f, 0.0f, 0.0f,
          0.6f,  0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
          0.6f,  0.1f, 0.0f, 1.0f, 0.0f, 0.0f,
          0.6f,  0.1f, 0.0f, 1.0f, 0.0f, 0.0f,
          0.6f,  0.1f, 0.2f, 1.0f, 0.0f, 0.0f,
          0.6f,  0.0f, 0.2f, 1.0f, 0.0f, 0.0f,

          0.6f,  0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
        0.7f,  0.0f, 0.0f, 0.0f, 0.0f, 1.0f,
        0.7f,  0.1f, 0.0f, 0.0f, 0.0f, 1.0f,
        0.7f,  0.1f, 0.0f, 0.0f, 0.0f, 1.0f,
        0.6f,  0.1f, 0.0f, 0.0f, 0.0f, 1.0f,
        0.6f,  0.0f, 0.0f, 0.0f, 0.0f, 1.0f,

        0.7f, 0.0f, 0.2f,  0.0f, 0.0f, -1.0f,
        0.6f, 0.0f, 0.2f, 0.0f, 0.0f, -1.0f,
        0.6f, 0.1f, 0.2f, 0.0f, 0.0f, -1.0f,
        0.6f, 0.1f, 0.2f, 0.0f, 0.0f, -1.0f,
        0.7f, 0.1f, 0.2f, 0.0f, 0.0f, -1.0f,
          0.7f, 0.0f, 0.2f, 0.0f, 0.0f, -1.0f,

          0.6f,  0.1f, 0.2f, 0.0f, -1.0f, 0.0f,
        0.6f,  0.1f, 0.0f, 0.0f, -1.0f, 0.0f,
        0.7f,  0.1f, 0.0f, 0.0f, -1.0f, 0.0f,
        0.7f,  0.1f, 0.0f, 0.0f, -1.0f, 0.0f,
        0.7f,  0.1f, 0.2f, 0.0f, -1.0f, 0.0f,
        0.6f,  0.1f, 0.2f, 0.0f, -1.0f, 0.0f,

          0.7f, 0.0f, 0.2f, 0.0f,  1.0f, 0.0f,
          0.7f, 0.0f, 0.0f, 0.0f,  1.0f, 0.0f,
          0.6f, 0.0f, 0.0f, 0.0f,  1.0f, 0.0f,
          0.6f, 0.0f, 0.0f, 0.0f,  1.0f, 0.0f,
          0.6f, 0.0f, 0.2f, 0.0f,  1.0f, 0.0f,
          0.7f, 0.0f, 0.2f, 0.0f,  1.0f, 0.0f,
          // ---------------------------------------------
            -0.4f,  0.35f, 0.4f, 1.0f, 0.0f, 0.0f,
            -0.4f,  0.35f, 0.35f, 1.0f, 0.0f, 0.0f,
            -0.4f,  0.45f, 0.35f, 1.0f, 0.0f, 0.0f,
            -0.4f,  0.45f, 0.35f, 1.0f, 0.0f, 0.0f,
            -0.4f,  0.45f, 0.4f, 1.0f, 0.0f, 0.0f,
            -0.4f,  0.35f, 0.4f, 1.0f, 0.0f, 0.0f,

            0.6f, 0.35f, 0.35f, -1.0f, 0.0f, 0.0f,
            0.6f, 0.35f, 0.4f, -1.0f, 0.0f, 0.0f,
            0.6f, 0.45f, 0.4f, -1.0f, 0.0f, 0.0f,
            0.6f, 0.45f, 0.4f, -1.0f, 0.0f, 0.0f,
            0.6f, 0.45f, 0.35f, -1.0f, 0.0f, 0.0f,
            0.6f, 0.35f, 0.35f, -1.0f, 0.0f, 0.0f,

            -0.4f, 0.35f, 0.4f, 0.0f, 1.0f, 0.0f,
            0.6f, 0.35f, 0.4f, 0.0f, 1.0f, 0.0f,
            0.6f, 0.35f, 0.35f, 0.0f, 1.0f, 0.0f,
            0.6f, 0.35f, 0.35f, 0.0f, 1.0f, 0.0f,
            -0.4f, 0.35f, 0.35f, 0.0f, 1.0f, 0.0f,
            -0.4f, 0.35f, 0.4f, 0.0f, 1.0f, 0.0f,

            -0.4f, 0.45f, 0.35f, 0.0f, -1.0f, 0.0f,
            0.6f, 0.45f, 0.35f, 0.0f, -1.0f, 0.0f,
            0.6f, 0.45f, 0.4f, 0.0f, -1.0f, 0.0f,
            0.6f, 0.45f, 0.4f, 0.0f, -1.0f, 0.0f,
            -0.4f, 0.45f, 0.4f, 0.0f, -1.0f, 0.0f,
            -0.4f, 0.45f, 0.35f, 0.0f, -1.0f, 0.0f,

            -0.4f, 0.35f, 0.35f, 0.0f, 0.0f, 1.0f,
            0.6f, 0.35f, 0.35f, 0.0f, 0.0f, 1.0f,
            0.6f, 0.45f, 0.35f, 0.0f, 0.0f, 1.0f,
            0.6f, 0.45f, 0.35f, 0.0f, 0.0f, 1.0f,
            -0.4f, 0.45f, 0.35f, 0.0f, 0.0f, 1.0f,
            -0.4f, 0.35f, 0.35f, 0.0f, 0.0f, 1.0f,
          // ---------------------------------------------
         -0.6f, 0.5f, 0.15f,  0.0f,  0.0f,  1.0f,
         -0.5f, 0.5f, 0.15f,  0.0f,  0.0f,  1.0f,
         -0.5f, 0.6f,  0.15f,  0.0f,  0.0f,  1.0f,
         -0.5f, 0.6f,  0.15f,  0.0f,  0.0f,  1.0f,
        -0.6f, 0.6f,  0.15f,  0.0f,  0.0f,  1.0f,
        -0.6f, 0.5f, 0.15f,  0.0f,  0.0f,  1.0f,

        -0.5f, 0.5f, 0.05f,  0.0f,  0.0f,  -1.0f,
         -0.6f, 0.5f, 0.05f,  0.0f,  0.0f,  -1.0f,
         -0.6f, 0.6f,  0.05f,  0.0f,  0.0f,  -1.0f,
         -0.6f, 0.6f,  0.05f,  0.0f,  0.0f,  -1.0f,
        -0.5f, 0.6f,  0.05f,  0.0f,  0.0f,  -1.0f,
        -0.5f, 0.5f, 0.05f,  0.0f,  0.0f,  -1.0f,

        -0.6f, 0.5f, 0.05f,  -1.0f,  0.0f,  0.0f,
         -0.6f, 0.5f, 0.15f,  -1.0f,  0.0f, 0.0f,
         -0.6f, 0.6f,  0.15f,  -1.0f,  0.0f,  0.0f,
         -0.6f, 0.6f,  0.15f,  -1.0f,  0.0f,  0.0f,
        -0.6f, 0.6f,  0.05f,  -1.0f,  0.0f,  0.0f,
        -0.6f, 0.5f, 0.05f,  -1.0f,  0.0f,  0.0f,

        -0.5f, 0.5f, 0.15f,  1.0f,  0.0f,  0.0f,
         -0.5f, 0.5f, 0.05f,  1.0f,  0.0f, 0.0f,
         -0.5f, 0.6f, 0.05f,  1.0f,  0.0f,  0.0f,
         -0.5f, 0.6f, 0.05f,  1.0f,  0.0f,  0.0f,
        -0.5f, 0.6f, 0.15f,  1.0f,  0.0f,  0.0f,
        -0.5f, 0.5f, 0.15f,  1.0f,  0.0f,  0.0f,

        -0.6f, 0.6f, 0.15f,  0.0f,  1.0f,  0.0f,
         -0.5f, 0.6f, 0.15f,  0.0f,  1.0f,  0.0f,
         -0.5f, 0.6f,  0.05f,  0.0f,  1.0f,  0.0f,
         -0.5f, 0.6f,  0.05f,  0.0f,  1.0f,  0.0f,
        -0.6f, 0.6f,  0.05f,  0.0f,  1.0f,  0.0f,
        -0.6f, 0.6f, 0.15f,  0.0f,  1.0f,  0.0f,
        // ---------------------------------------------
         0.7f, 0.275f, 0.125f, 0.0f, 0.0f, 1.0f,
         0.75f, 0.275f, 0.125f, 0.0f, 0.0f, 1.0f,
         0.75f, 0.325f, 0.125f, 0.0f, 0.0f, 1.0f,
         0.75f, 0.325f, 0.125f, 0.0f, 0.0f, 1.0f,
         0.7f, 0.325f, 0.125f, 0.0f, 0.0f, 1.0f,
         0.7f, 0.275f, 0.125f, 0.0f, 0.0f, 1.0f,

         0.75f, 0.275f, 0.075f, 0.0f, 0.0f, -1.0f,
        0.7f, 0.275f, 0.075f, 0.0f, 0.0f, -1.0f,
        0.7f, 0.325f, 0.075f, 0.0f, 0.0f, -1.0f,
        0.7f, 0.325f, 0.075f, 0.0f, 0.0f, -1.0f,
         0.75f, 0.325f, 0.075f, 0.0f, 0.0f, -1.0f,
         0.75f, 0.275f, 0.075f, 0.0f, 0.0f, -1.0f,

         0.7f, 0.275f, 0.075f, 0.0f, -1.0f, 0.0f,
         0.75f, 0.275f, 0.075f, 0.0f, -1.0f, 0.0f,
         0.75f, 0.275f, 0.125f, 0.0f, -1.0f, 0.0f,
         0.75f, 0.275f, 0.125f, 0.0f, -1.0f, 0.0f,
         0.7f, 0.275f, 0.125f, 0.0f, -1.0f, 0.0f,
         0.7f, 0.275f, 0.075f, 0.0f, -1.0f, 0.0f,

         0.7f, 0.325f, 0.125f, 0.0f,  1.0f, 0.0f,
         0.75f, 0.325f, 0.125f, 0.0f,  1.0f, 0.0f,
         0.75f, 0.325f, 0.075f, 0.0f,  1.0f, 0.0f,
         0.75f, 0.325f, 0.075f, 0.0f,  1.0f, 0.0f,
         0.7f, 0.325f, 0.075f, 0.0f,  1.0f, 0.0f,
         0.7f, 0.325f, 0.125f, 0.0f,  1.0f, 0.0f,
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[1]);
    glBindVertexArray(VAO[1]);

    glGenBuffers(1, &VBO[1]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[1]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices2), vertices2, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // ANTHENA BOTTOM
    float vertices3[] =
    {
        //X     Y      Z       NX    NY     NZ
        -0.5625f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.55625f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.55625f, 0.85f,  0.1125f,  0.0f,  0.0f,  1.0f,
         -0.55625f, 0.85f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.5625f, 0.85f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.5625f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,

        -0.55625f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.54375f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.54375f, 0.8f,  0.1125f,  0.0f,  0.0f,  1.0f,
         -0.54375f, 0.8f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.55625f, 0.8f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.55625f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,

        -0.54375f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.5375f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.5375f, 0.85f,  0.1125f,  0.0f,  0.0f,  1.0f,
         -0.5375f, 0.85f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.54375f, 0.85f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.54375f, 0.6f, 0.1125f,  0.0f,  0.0f,  1.0f,
        // ---------------------------------------------
        -0.55625f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.5625f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.5625f, 0.85f,  0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.5625f, 0.85f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.55625f, 0.85f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.55625f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,

        -0.54375f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.55625f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.55625f, 0.8f,  0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.55625f, 0.8f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.54375f, 0.8f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.54375f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,

        -0.5375f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.54375f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.54375f, 0.85f,  0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.54375f, 0.85f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.5375f, 0.85f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.5375f, 0.6f, 0.0875f,  0.0f,  0.0f,  -1.0f,
        // ---------------------------------------------
        -0.5625f, 0.6f, 0.0875f,  -1.0f,  0.0f,  0.0f,
         -0.5625f, 0.6f, 0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.5625f, 0.85f,  0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.5625f, 0.85f,  0.1125f,  -1.0f,  0.0f,  0.0f,
        -0.5625f, 0.85f,  0.0875f,  -1.0f,  0.0f,  0.0f,
        -0.5625f, 0.6f, 0.0875f,  -1.0f,  0.0f,  0.0f,

        -0.5375f, 0.6f, 0.1125f,  1.0f,  0.0f,  0.0f,
         -0.5375f, 0.6f, 0.0875f,  1.0f,  0.0f,  0.0f,
         -0.5375f, 0.85f,  0.0875f,  1.0f,  0.0f,  0.0f,
         -0.5375f, 0.85f,  0.0875f,  1.0f,  0.0f,  0.0f,
        -0.5375f, 0.85f,  0.1125f,  1.0f,  0.0f,  0.0f,
        -0.5375f, 0.6f, 0.1125f,  1.0f,  0.0f,  0.0f,

        -0.55625f, 0.8f, 0.1125f,  1.0f,  0.0f,  0.0f,
         -0.55625f, 0.8f, 0.0875f,  1.0f,  0.0f,  0.0f,
         -0.55625f, 0.85f,  0.0875f,  1.0f,  0.0f,  0.0f,
         -0.55625f, 0.85f,  0.0875f,  1.0f,  0.0f,  0.0f,
        -0.55625f, 0.85f,  0.1125f,  1.0f,  0.0f,  0.0f,
        -0.55625f, 0.8f, 0.1125f,  1.0f,  0.0f,  0.0f,

        -0.54375f, 0.8f, 0.0875f,  -1.0f,  0.0f,  0.0f,
         -0.54375f, 0.8f, 0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.54375f, 0.85f,  0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.54375f, 0.85f,  0.1125f,  -1.0f,  0.0f,  0.0f,
        -0.54375f, 0.85f,  0.0875f,  -1.0f,  0.0f,  0.0f,
        -0.54375f, 0.8f, 0.0875f,  -1.0f,  0.0f,  0.0f,
        // ---------------------------------------------
        -0.5625f, 0.85f, 0.1125f,  0.0f,  1.0f,  0.0f,
         -0.55625f, 0.85f, 0.1125f,  0.0f,  1.0f,  0.0f,
         -0.55625f, 0.85f,  0.0875f,  0.0f,  1.0f,  0.0f,
         -0.55625f, 0.85f,  0.0875f,  0.0f,  1.0f,  0.0f,
        -0.5625f, 0.85f,  0.0875f,  0.0f,  1.0f,  0.0f,
        -0.5625f, 0.85f, 0.1125f,  0.0f,  1.0f,  0.0f,

        -0.54375f, 0.85f, 0.1125f,  0.0f,  1.0f,  0.0f,
         -0.5375f, 0.85f, 0.1125f,  0.0f,  1.0f,  0.0f,
         -0.5375f, 0.85f,  0.0875f,  0.0f,  1.0f,  0.0f,
         -0.5375f, 0.85f,  0.0875f,  0.0f,  1.0f,  0.0f,
        -0.54375f, 0.85f,  0.0875f,  0.0f,  1.0f,  0.0f,
        -0.54375f, 0.85f, 0.1125f,  0.0f,  1.0f,  0.0f,

        -0.55625f, 0.8f, 0.1125f,  0.0f,  1.0f,  0.0f,
         -0.54375f, 0.8f, 0.1125f,  0.0f,  1.0f,  0.0f,
         -0.54375f, 0.8f,  0.0875f,  0.0f,  1.0f,  0.0f,
         -0.54375f, 0.8f,  0.0875f,  0.0f,  1.0f,  0.0f,
        -0.55625f, 0.8f,  0.0875f,  0.0f,  1.0f,  0.0f,
        -0.55625f, 0.8f, 0.1125f,  0.0f,  1.0f,  0.0f,
        // ---------------------------------------------
        -0.55625f, 0.8125f, 0.10625f, 0.0f, 0.0f, 1.0f,
        -0.54375f, 0.8125f, 0.10625f, 0.0f, 0.0f, 1.0f,
        -0.54375f, 0.825f, 0.10625f, 0.0f, 0.0f, 1.0f,
        -0.54375f, 0.825f, 0.10625f, 0.0f, 0.0f, 1.0f,
        -0.55625f, 0.825f, 0.10625f, 0.0f, 0.0f, 1.0f,
        -0.55625f, 0.8125f, 0.10625f, 0.0f, 0.0f, 1.0f,

        -0.54375f, 0.8125f, 0.09375f, 0.0f, 0.0f, -1.0f,
        -0.55625f, 0.8125f, 0.09375f, 0.0f, 0.0f, -1.0f,
        -0.55625f, 0.825f, 0.09375f, 0.0f, 0.0f, -1.0f,
        -0.55625f, 0.825f, 0.09375f, 0.0f, 0.0f, -1.0f,
        -0.54375f, 0.825f, 0.09375f, 0.0f, 0.0f, -1.0f,
        -0.54375f, 0.8125f, 0.09375f, 0.0f, 0.0f, -1.0f,

        -0.55625f, 0.8125f, 0.09375f, 0.0f, -1.0f, 0.0f,
        -0.54375f, 0.8125f, 0.09375f, 0.0f, -1.0f, 0.0f,
        -0.54375f, 0.8125f, 0.10625f, 0.0f, -1.0f, 0.0f,
        -0.54375f, 0.8125f, 0.10625f, 0.0f, -1.0f, 0.0f,
        -0.55625f, 0.8125f, 0.10625f, 0.0f, -1.0f, 0.0f,
        -0.55625f, 0.8125f, 0.09375f, 0.0f, -1.0f, 0.0f,

        -0.55625f, 0.825f, 0.10625f, 0.0f, 1.0f, 0.0f,
        -0.54375f, 0.825f, 0.10625f, 0.0f, 1.0f, 0.0f,
        -0.54375f, 0.825f, 0.09375f, 0.0f, 1.0f, 0.0f,
        -0.54375f, 0.825f, 0.09375f, 0.0f, 1.0f, 0.0f,
        -0.55625f, 0.825f, 0.09375f, 0.0f, 1.0f, 0.0f,
        -0.55625f, 0.825f, 0.10625f, 0.0f, 1.0f, 0.0f
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[2]);
    glBindVertexArray(VAO[2]);

    glGenBuffers(1, &VBO[2]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[2]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices3), vertices3, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // ANTHENA TOP
    float vertices4[] =
    {
        //X     Y      Z       NX    NY     NZ
        -0.5625f, 0.853125f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.553125f, 0.853125f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.553125f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
         -0.553125f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.5625f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.5625f, 0.853125f, 0.1125f,  0.0f,  0.0f,  1.0f,

        -0.546875f, 0.853125f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.5375f, 0.853125f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.5375f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
         -0.5375f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.546875f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.546875f, 0.853125f, 0.1125f,  0.0f,  0.0f,  1.0f,

        -0.553125f, 0.803125f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.546875f, 0.803125f, 0.1125f,  0.0f,  0.0f,  1.0f,
         -0.546875f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
         -0.546875f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.553125f, 1.2f,  0.1125f,  0.0f,  0.0f,  1.0f,
        -0.553125f, 0.803125f, 0.1125f,  0.0f,  0.0f,  1.0f,

        -0.553125f, 0.853125f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.5625f, 0.853125f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.5625f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.5625f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.553125f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.553125f, 0.853125f, 0.0875f,  0.0f,  0.0f,  -1.0f,

        -0.5375f, 0.853125f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.546875f, 0.853125f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.546875f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.546875f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.5375f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.5375f, 0.853125f, 0.0875f,  0.0f,  0.0f,  -1.0f,

        -0.546875f, 0.803125f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.553125f, 0.803125f, 0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.553125f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
         -0.553125f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.546875f, 1.2f,  0.0875f,  0.0f,  0.0f,  -1.0f,
        -0.546875f, 0.803125f, 0.0875f,  0.0f,  0.0f,  -1.0f,
        // ---------------------------------------------
        -0.5625f, 0.853125f, 0.0875f,  -1.0f,  0.0f,  0.0f,
         -0.5625f, 0.853125f, 0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.5625f, 1.2f,  0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.5625f, 1.2f,  0.1125f,  -1.0f,  0.0f,  0.0f,
        -0.5625f, 1.2f,  0.0875f,  -1.0f,  0.0f,  0.0f,
        -0.5625f, 0.853125f, 0.0875f,  -1.0f,  0.0f,  0.0f,

        -0.5375f, 0.853125f, 0.1125f,  1.0f,  0.0f,  0.0f,
         -0.5375f, 0.853125f, 0.0875f,  1.0f,  0.0f,  0.0f,
         -0.5375f, 1.2f,  0.0875f,  1.0f,  0.0f,  0.0f,
         -0.5375f, 1.2f,  0.0875f,  1.0f,  0.0f,  0.0f,
        -0.5375f, 1.2f,  0.1125f,  1.0f,  0.0f,  0.0f,
        -0.5375f, 0.853125f, 0.1125f,  1.0f,  0.0f,  0.0f,

        -0.553125f, 0.803125f, 0.0875f,  -1.0f,  0.0f,  0.0f,
         -0.553125f, 0.803125f, 0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.553125f, 1.2f,  0.1125f,  -1.0f,  0.0f,  0.0f,
         -0.553125f, 1.2f,  0.1125f,  -1.0f,  0.0f,  0.0f,
        -0.553125f, 1.2f,  0.0875f,  -1.0f,  0.0f,  0.0f,
        -0.553125f, 0.803125f, 0.0875f,  -1.0f,  0.0f,  0.0f,

        -0.546875f, 0.803125f, 0.1125f,  1.0f,  0.0f,  0.0f,
         -0.546875f, 0.803125f, 0.0875f,  1.0f,  0.0f,  0.0f,
         -0.546875f, 1.2f,  0.0875f,  1.0f,  0.0f,  0.0f,
         -0.546875f, 1.2f,  0.0875f,  1.0f,  0.0f,  0.0f,
        -0.546875f, 1.2f,  0.1125f,  1.0f,  0.0f,  0.0f,
        -0.546875f, 0.803125f, 0.1125f,  1.0f,  0.0f,  0.0f,
        // ---------------------------------------------
        -0.5625f, 0.853125f, 0.0875f,  0.0f,  -1.0f,  0.0f,
         -0.553125f, 0.853125f, 0.0875f,  0.0f,  -1.0f,  0.0f,
         -0.553125f, 0.853125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
         -0.553125f, 0.853125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
        -0.5625f, 0.853125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
        -0.5625f, 0.853125f, 0.0875f,  0.0f,  -1.0f,  0.0f,

        -0.546875f, 0.853125f, 0.0875f,  0.0f,  -1.0f,  0.0f,
         -0.5375f, 0.853125f, 0.0875f,  0.0f,  -1.0f,  0.0f,
         -0.5375f, 0.853125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
         -0.5375f, 0.853125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
        -0.546875f, 0.853125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
        -0.546875f, 0.853125f, 0.0875f,  0.0f,  -1.0f,  0.0f,

        -0.553125f, 0.803125f, 0.0875f,  0.0f,  -1.0f,  0.0f,
         -0.546875f, 0.803125f, 0.0875f,  0.0f,  -1.0f,  0.0f,
         -0.546875f, 0.803125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
         -0.546875f, 0.803125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
        -0.553125f, 0.803125f,  0.1125f,  0.0f,  -1.0f,  0.0f,
        -0.553125f, 0.803125f, 0.0875f,  0.0f,  -1.0f,  0.0f,
        // ---------------------------------------------
        -0.6f, 1.2f, 0.15f,  0.0f,  0.0f,  1.0f,
         -0.5f, 1.2f, 0.15f,  0.0f,  0.0f,  1.0f,
         -0.5f, 1.2125f,  0.15f,  0.0f,  0.0f,  1.0f,
         -0.5f, 1.2125f,  0.15f,  0.0f,  0.0f,  1.0f,
        -0.6f, 1.2125f,  0.15f,  0.0f,  0.0f,  1.0f,
        -0.6f, 1.2f, 0.15f,  0.0f,  0.0f,  1.0f,

        -0.5f, 1.2f, 0.05f, 0.0f, 0.0f, -1.0f,
        -0.6f, 1.2f, 0.05f, 0.0f, 0.0f, -1.0f,
        -0.6f, 1.2125f, 0.05f, 0.0f, 0.0f, -1.0f,
        -0.6f, 1.2125f, 0.05f, 0.0f, 0.0f, -1.0f,
        -0.5f, 1.2125f, 0.05f, 0.0f, 0.0f, -1.0f,
        -0.5f, 1.2f, 0.05f, 0.0f, 0.0f, -1.0f,

        -0.6f, 1.2f, 0.05f, -1.0f, 0.0f, 0.0f,
        -0.6f, 1.2f, 0.15f, -1.0f, 0.0f, 0.0f,
        -0.6f, 1.2125f, 0.15f, -1.0f, 0.0f, 0.0f,
        -0.6f, 1.2125f, 0.15f, -1.0f, 0.0f, 0.0f,
        -0.6f, 1.2125f, 0.05f, -1.0f, 0.0f, 0.0f,
        -0.6f, 1.2f, 0.05f, -1.0f, 0.0f, 0.0f,

        -0.5f, 1.2f, 0.15f, 1.0f, 0.0f, 0.0f,
        -0.5f, 1.2f, 0.05f, 1.0f, 0.0f, 0.0f,
        -0.5f, 1.2125f, 0.05f, 1.0f, 0.0f, 0.0f,
        -0.5f, 1.2125f, 0.05f, 1.0f, 0.0f, 0.0f,
        -0.5f, 1.2125f, 0.15f, 1.0f, 0.0f, 0.0f,
        -0.5f, 1.2f, 0.15f, 1.0f, 0.0f, 0.0f,

        -0.6f, 1.2f, 0.05f, 0.0f, -1.0f, 0.0f,
        -0.5f, 1.2f, 0.05f, 0.0f, -1.0f, 0.0f,
        -0.5f, 1.2f, 0.15f, 0.0f, -1.0f, 0.0f,
        -0.5f, 1.2f, 0.15f, 0.0f, -1.0f, 0.0f,
        -0.6f, 1.2f, 0.15f, 0.0f, -1.0f, 0.0f,
        -0.6f, 1.2f, 0.05f, 0.0f, -1.0f, 0.0f,

        -0.6f, 1.2125f, 0.15f, 0.0f, 1.0f, 0.0f,
        -0.5f, 1.2125f, 0.15f, 0.0f, 1.0f, 0.0f,
        -0.5f, 1.2125f, 0.05f, 0.0f, 1.0f, 0.0f,
        -0.5f, 1.2125f, 0.05f, 0.0f, 1.0f, 0.0f,
        -0.6f, 1.2125f, 0.05f, 0.0f, 1.0f, 0.0f,
        -0.6f, 1.2125f, 0.15f, 0.0f, 1.0f, 0.0f
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[3]);
    glBindVertexArray(VAO[3]);

    glGenBuffers(1, &VBO[3]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[3]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices4), vertices4, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // AMFM SWITCH
    float vertices5[] =
    {
        //X     Y      Z       NX    NY     NZ
          0.75f,  0.0f, 0.1f, 1.0f, 0.0f, 0.0f,
          0.75f,  0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
          0.75f,  0.1f, 0.0f, 1.0f, 0.0f, 0.0f,
          0.75f,  0.1f, 0.0f, 1.0f, 0.0f, 0.0f,
          0.75f,  0.1f, 0.1f, 1.0f, 0.0f, 0.0f,
          0.75f,  0.0f, 0.1f, 1.0f, 0.0f, 0.0f,

          0.6f,  0.0f, 0.1f,  0.0f, 0.0f, 1.0f,
          0.75f,  0.0f, 0.1f,  0.0f, 0.0f, 1.0f,
          0.75f,  0.1f, 0.1f,  0.0f, 0.0f, 1.0f,
          0.75f,  0.1f, 0.1f,  0.0f, 0.0f, 1.0f,
          0.6f,  0.1f, 0.1f,  0.0f, 0.0f, 1.0f,
          0.6f,  0.0f, 0.1f,  0.0f, 0.0f, 1.0f,

          0.75f, 0.0f, 0.0f,  0.0f, 0.0f, -1.0f,
          0.6f, 0.0f, 0.0f,  0.0f, 0.0f, -1.0f,
          0.6f, 0.1f, 0.0f,  0.0f, 0.0f, -1.0f,
          0.6f, 0.1f, 0.0f,  0.0f, 0.0f, -1.0f,
          0.75f, 0.1f, 0.0f,  0.0f, 0.0f, -1.0f,
          0.75f, 0.0f, 0.0f,  0.0f, 0.0f, -1.0f,

          0.6f,  0.1f, 0.1f, 0.0f, 1.0f, 0.0f,
          0.75f,  0.1f, 0.1f, 0.0f, 1.0f, 0.0f,
          0.75f,  0.1f, 0.0f, 0.0f, 1.0f, 0.0f,
          0.75f,  0.1f, 0.0f, 0.0f, 1.0f, 0.0f,
          0.6f,  0.1f, 0.0f, 0.0f, 1.0f, 0.0f,
          0.6f,  0.1f, 0.1f, 0.0f, 1.0f, 0.0f,

          0.6f, 0.0f, 0.0f, 0.0f,  -1.0f, 0.0f,
          0.75f, 0.0f, 0.0f, 0.0f,  -1.0f, 0.0f,
          0.75f, 0.0f, 0.1f, 0.0f,  -1.0f, 0.0f,
          0.75f, 0.0f, 0.1f, 0.0f,  -1.0f, 0.0f,
          0.6f, 0.0f, 0.1f, 0.0f,  -1.0f, 0.0f,
          0.6f, 0.0f, 0.0f, 0.0f,  -1.0f, 0.0f,
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[4]);
    glBindVertexArray(VAO[4]);

    glGenBuffers(1, &VBO[4]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[4]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices5), vertices5, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // ONOFF SWITCH
    float vertices6[] =
    {
        //X     Y      Z       NX    NY     NZ
          -0.6f,  0.35f, 0.45f, 0.0f, 0.0f, 1.0f,
          -0.5f,  0.35f, 0.45f, 0.0f, 0.0f, 1.0f,
          -0.5f,  0.45f, 0.45f, 0.0f, 0.0f, 1.0f,
          -0.5f,  0.45f, 0.45f, 0.0f, 0.0f, 1.0f,
          -0.6f,  0.45f, 0.45f, 0.0f, 0.0f, 1.0f,
          -0.6f,  0.35f, 0.45f, 0.0f, 0.0f, 1.0f,

          -0.6f,  0.35f, 0.4f, -1.0f, 0.0f, 0.0f,
          -0.6f,  0.35f, 0.45f, -1.0f, 0.0f, 0.0f,
          -0.6f,  0.45f, 0.45f, -1.0f, 0.0f, 0.0f,
          -0.6f,  0.45f, 0.45f, -1.0f, 0.0f, 0.0f,
          -0.6f,  0.45f, 0.4f, -1.0f, 0.0f, 0.0f,
          -0.6f,  0.35f, 0.4f, -1.0f, 0.0f, 0.0f,

          -0.5f,  0.35f, 0.45f, 1.0f, 0.0f, 0.0f,
          -0.5f,  0.35f, 0.4f, 1.0f, 0.0f, 0.0f,
          -0.5f,  0.45f, 0.4f, 1.0f, 0.0f, 0.0f,
          -0.5f,  0.45f, 0.4f, 1.0f, 0.0f, 0.0f,
          -0.5f,  0.45f, 0.45f, 1.0f, 0.0f, 0.0f,
          -0.5f,  0.35f, 0.45f, 1.0f, 0.0f, 0.0f,

          -0.6f,  0.35f, 0.4f,  0.0f, -1.0f, 0.0f,
          -0.5f,  0.35f, 0.4f,  0.0f, -1.0f, 0.0f,
          -0.5f,  0.35f, 0.45f,  0.0f, -1.0f, 0.0f,
          -0.5f,  0.35f, 0.45f,  0.0f, -1.0f, 0.0f,
          -0.6f,  0.35f, 0.45f,  0.0f, -1.0f, 0.0f,
          -0.6f,  0.35f, 0.4f,  0.0f, -1.0f, 0.0f,

          -0.6f,  0.45f, 0.45f,  0.0f, 1.0f, 0.0f,
          -0.5f,  0.45f, 0.45f,  0.0f, 1.0f, 0.0f,
          -0.5f,  0.45f, 0.4f,  0.0f, 1.0f, 0.0f,
          -0.5f,  0.45f, 0.4f,  0.0f, 1.0f, 0.0f,
          -0.6f,  0.45f, 0.4f,  0.0f, 1.0f, 0.0f,
          -0.6f,  0.45f, 0.45f,  0.0f, 1.0f, 0.0f
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[5]);
    glBindVertexArray(VAO[5]);

    glGenBuffers(1, &VBO[5]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[5]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices6), vertices6, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // VOLUME SWITCH
    float vertices7[] =
    {
        //X     Y      Z       NX    NY     NZ
           0.0f,  -0.2f, 0.3f, 0.0f, -1.0f, 0.0f,
           0.1f,  -0.2f, 0.3f, 0.0f, -1.0f, 0.0f,
           0.1f,  -0.2f, 0.45f, 0.0f, -1.0f, 0.0f,
           0.1f,  -0.2f, 0.45f, 0.0f, -1.0f, 0.0f,
           0.0f,  -0.2f, 0.45f, 0.0f, -1.0f, 0.0f,
           0.0f,  -0.2f, 0.3f, 0.0f, -1.0f, 0.0f,

           0.0f,  -0.1f, 0.45f, 0.0f, 1.0f, 0.0f,
           0.1f,  -0.1f, 0.45f, 0.0f, 1.0f, 0.0f,
           0.1f,  -0.1f, 0.3f, 0.0f, 1.0f, 0.0f,
           0.1f,  -0.1f, 0.3f, 0.0f, 1.0f, 0.0f,
           0.0f,  -0.1f, 0.3f, 0.0f, 1.0f, 0.0f,
           0.0f,  -0.1f, 0.45f, 0.0f, 1.0f, 0.0f,

           0.0f,  -0.2f, 0.3f,  -1.0f, 0.0f, 0.0f,
           0.0f,  -0.2f, 0.45f, -1.0f, 0.0f, 0.0f,
           0.0f,  -0.1f, 0.45f, -1.0f, 0.0f, 0.0f,
           0.0f,  -0.1f, 0.45f, -1.0f, 0.0f, 0.0f,
           0.0f,  -0.1f, 0.3f, -1.0f, 0.0f, 0.0f,
           0.0f,  -0.2f, 0.3f, -1.0f, 0.0f, 0.0f,

           0.1f,  -0.2f, 0.45f,  1.0f, 0.0f, 0.0f,
           0.1f,  -0.2f, 0.3f, 1.0f, 0.0f, 0.0f,
           0.1f,  -0.1f, 0.3f, 1.0f, 0.0f, 0.0f,
           0.1f,  -0.1f, 0.3f, 1.0f, 0.0f, 0.0f,
           0.1f,  -0.1f, 0.45f, 1.0f, 0.0f, 0.0f,
           0.1f,  -0.2f, 0.45f, 1.0f, 0.0f, 0.0f,

           0.0f,  -0.2f, 0.45f,  0.0f, 0.0f, 1.0f,
           0.1f,  -0.2f, 0.45f,  0.0f, 0.0f, 1.0f,
           0.1f,  -0.1f, 0.45f,  0.0f, 0.0f, 1.0f,
           0.1f,  -0.1f, 0.45f,  0.0f, 0.0f, 1.0f,
           0.0f,  -0.1f, 0.45f,  0.0f, 0.0f, 1.0f,
           0.0f,  -0.2f, 0.45f,  0.0f, 0.0f, 1.0f,
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[6]);
    glBindVertexArray(VAO[6]);

    glGenBuffers(1, &VBO[6]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[6]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices7), vertices7, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // VOLUME BAR
    float vertices8[] =
    {
        //X     Y      Z       NX    NY     NZ
           -0.6f,  0.1f, 0.3001f,  0.0f, 0.0f, 1.0f,
           0.0f,  0.1f, 0.3001f,  0.0f, 0.0f, 1.0f,
           0.0f,  0.2f, 0.3001f,  0.0f, 0.0f, 1.0f,
           0.0f,  0.2f, 0.3001f,  0.0f, 0.0f, 1.0f,
           -0.6f,  0.2f, 0.3001f,  0.0f, 0.0f, 1.0f,
           -0.6f,  0.1f, 0.3001f,  0.0f, 0.0f, 1.0f,
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[7]);
    glBindVertexArray(VAO[7]);

    glGenBuffers(1, &VBO[7]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[7]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices8), vertices8, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // SCALE
    float vertices9[] =
    {   
        //X     Y      Z       NX    NY     NZ
        -0.4f,  0.35f, 0.3501f,  0.0f, 0.0f, 1.0,
         0.6f,  0.35f, 0.3501f,  0.0f, 0.0f, 1.0,
         0.6f,  0.45f, 0.3501f,  0.0f, 0.0f, 1.0,
         0.6f,  0.45f, 0.3501f,  0.0f, 0.0f, 1.0,
        -0.4f,  0.45f, 0.3501f,  0.0f, 0.0f, 1.0,
        -0.4f,  0.35f, 0.3501f,  0.0f, 0.0f, 1.0,
    };

    glGenVertexArrays(1, &VAO[8]);
    glBindVertexArray(VAO[8]);

    glGenBuffers(1, &VBO[8]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[8]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices9), vertices9, GL_STATIC_DRAW);

    stride = (3 + 3) * sizeof(float);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // NUMBER SCALE 
    float vertices10[] =
    {   
        //X     Y      Z       NX    NY     NZ
        -0.4f,  0.395f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.6f,  0.395f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.6f,  0.405f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.6f,  0.405f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.4f,  0.405f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.4f,  0.395f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.355f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         -0.345f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         -0.345f,  0.425, 0.35011f,  0.0f, 0.0f, 1.0,
         -0.345f,  0.425, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.355f,  0.425, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.355f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.305f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.295f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.295f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.295f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.305f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.305f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.255f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.245f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.245f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.245f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.255f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.255f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.205f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.195f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.195f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.195f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.205f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.205f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.155f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.145f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.145f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.145f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.155f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.155f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.105f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.095f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.095f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.095f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.105f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.105f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.055f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.045f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.045f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.045f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.055f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.055f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

        -0.005f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.005f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.005f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.005f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.005f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
        -0.005f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

         0.045f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.055f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.055f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.055f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.045f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.045f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

         0.095f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.105f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.105f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.105f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.095f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.095f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

         0.145f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.155f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.155f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.155f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.145f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.145f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

         0.195f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.205f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.205f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.205f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.195f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.195f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

         0.245f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.255f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.255f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.255f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.245f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.245f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

         0.295f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.305f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.305f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.305f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.295f,  0.425f, 0.35011f,  0.0f, 0.0f, 1.0,
         0.295f,  0.375f, 0.35011f,  0.0f, 0.0f, 1.0,

         0.345f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.355f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.355f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.355f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.345f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.345f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,

         0.395f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.405f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.405f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.405f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.395f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.395f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,

         0.445f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.455f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.455f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.455f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.445f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.445f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,

         0.495f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.505f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.505f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.505f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.495f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.495f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,

         0.545f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.555f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.555f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.555f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.545f, 0.425f, 0.35011f, 0.0f, 0.0f, 1.0,
         0.545f, 0.375f, 0.35011f, 0.0f, 0.0f, 1.0,
    };

    glGenVertexArrays(1, &VAO[9]);
    glBindVertexArray(VAO[9]);

    glGenBuffers(1, &VBO[9]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[9]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices10), vertices10, GL_STATIC_DRAW);

    stride = (3 + 3) * sizeof(float);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // ARROW
    float vertices11[] =
    {   
        //X     Y      Z       NX    NY     NZ
        -0.36f,  0.35f, 0.35012f,  0.0f, 0.0f, 1.0,
         -0.34f,  0.35f, 0.35012f,  0.0f, 0.0f, 1.0,
         -0.35f,  0.42, 0.350112,  0.0f, 0.0f, 1.0,
    };

    glGenVertexArrays(1, &VAO[10]);
    glBindVertexArray(VAO[10]);

    glGenBuffers(1, &VBO[10]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[10]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices11), vertices11, GL_STATIC_DRAW);

    stride = (3 + 3) * sizeof(float);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // CONTROL KNOB
    std::vector<float> vertices12;
    generateCylinderVertices(0.1f, 0.1f, 36, vertices12);

    glGenVertexArrays(1, &VAO[11]);
    glBindVertexArray(VAO[11]);

    glGenBuffers(1, &VBO[11]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[11]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float)* vertices12.size(), vertices12.data(), GL_STATIC_DRAW);

    stride = (3 + 3) * sizeof(float);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // KNOB ARROW
    float vertices13[] =
    {
        //X     Y      Z       NX    NY     NZ
         0.825f, 0.35f, 0.11f, 0.0f, 0.0f, 1.0f,
         0.855f, 0.35f, 0.11f, 0.0f, 0.0f, 1.0f,
         0.855f, 0.405f, 0.11f, 0.0f, 0.0f, 1.0f,
         0.855f, 0.405f, 0.11f, 0.0f, 0.0f, 1.0f,
         0.825f, 0.405f, 0.11f, 0.0f, 0.0f, 1.0f,
         0.825f, 0.35f, 0.11f, 0.0f, 0.0f, 1.0f,

         0.855f, 0.35f, 0.09f, 0.0f, 0.0f, -1.0f,
         0.825f, 0.35f, 0.09f, 0.0f, 0.0f, -1.0f,
         0.825f, 0.405f, 0.09f, 0.0f, 0.0f, -1.0f,
         0.825f, 0.405f, 0.09f, 0.0f, 0.0f, -1.0f,
         0.855f, 0.405f, 0.09f, 0.0f, 0.0f, -1.0f,
         0.855f , 0.35f, 0.09f, 0.0f, 0.0f, -1.0f,

         0.825f, 0.35f, 0.09f, 0.0f, -1.0f,  0.0f,
         0.855f, 0.35f, 0.09f, 0.0f, -1.0f,  0.0f,
         0.855f, 0.35f, 0.11f, 0.0f, -1.0f,  0.0f,
         0.855f, 0.35f, 0.11f, 0.0f, -1.0f,  0.0f,
         0.825f, 0.35f, 0.11f, 0.0f, -1.0f,  0.0f,
         0.825f, 0.35f, 0.09f, 0.0f, -1.0f,  0.0f,

         0.825f, 0.405f, 0.11f, 0.0f, 1.0f,  0.0f,
         0.855f, 0.405f, 0.11f, 0.0f, 1.0f,  0.0f,
         0.855f, 0.405f, 0.09f, 0.0f, 1.0f,  0.0f,
         0.855f, 0.405f, 0.09f, 0.0f, 1.0f,  0.0f,
         0.825f, 0.405f, 0.09f, 0.0f, 1.0f,  0.0f,
         0.825f, 0.405f, 0.11f, 0.0f, 1.0f,  0.0f,

         0.825f, 0.35f, 0.09f, -1.0f, 0.0f,  0.0f,
         0.825f, 0.35f, 0.11f, -1.0f, 0.0f,  0.0f,
         0.825f, 0.405f, 0.11f, -1.0f, 0.0f,  0.0f,
         0.825f, 0.405f, 0.11f, -1.0f, 0.0f,  0.0f,
         0.825f, 0.405f, 0.09f, -1.0f, 0.0f,  0.0f,
         0.825f, 0.35f, 0.09f, -1.0f, 0.0f,  0.0f,

         0.855f, 0.35f, 0.11f, 1.0f, 0.0f,  0.0f,
         0.855f, 0.35f, 0.09f, 1.0f, 0.0f,  0.0f,
         0.855f, 0.405f, 0.09f, 1.0f, 0.0f,  0.0f,
         0.855f, 0.405f, 0.09f, 1.0f, 0.0f,  0.0f,
         0.855f, 0.405f, 0.11f, 1.0f, 0.0f,  0.0f,
         0.855f, 0.35f, 0.11f, 1.0f, 0.0f,  0.0f,
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[12]);
    glBindVertexArray(VAO[12]);

    glGenBuffers(1, &VBO[12]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[12]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices13), vertices13, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // MEMBRANE
    std::vector<float> vertices14;
    generateConeVertices(0.225f, 0.075f, 36, vertices14);

    glGenVertexArrays(1, &VAO[13]);
    glBindVertexArray(VAO[13]);

    glGenBuffers(1, &VBO[13]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[13]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float)* vertices14.size(), vertices14.data(), GL_STATIC_DRAW);

    stride = (3 + 3) * sizeof(float);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // SPEAKER
    std::vector<float> vertices15;
    generateCylinderVertices(0.05f, 0.04f, 36, vertices15);

    glGenVertexArrays(1, &VAO[14]);
    glBindVertexArray(VAO[14]);

    glGenBuffers(1, &VBO[14]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[14]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float)* vertices15.size(), vertices15.data(), GL_STATIC_DRAW);

    stride = (3 + 3) * sizeof(float);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // MESH
    std::vector<float> vertices16;
    generateMeshVertices(vertices16);

    glGenVertexArrays(1, &VAO[15]);
    glBindVertexArray(VAO[15]);

    glGenBuffers(1, &VBO[15]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[15]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float)* vertices16.size(), vertices16.data(), GL_STATIC_DRAW);

    stride = (3 + 3) * sizeof(float);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // AM
    float vertices17[] =
    {
        //X     Y      Z       NX    NY     NZ    S    T
         0.7001f, 0.0f, 0.3f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
         0.7001f, 0.0f, 0.2f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
         0.7001f, 0.1f, 0.2f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,
         0.7001f, 0.1f, 0.2f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,
         0.7001f, 0.1f, 0.3f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
         0.7001f, 0.0f, 0.3f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
    };
    stride = (3 + 3 + 2) * sizeof(float);

    glGenVertexArrays(1, &VAO[16]);
    glBindVertexArray(VAO[16]);

    glGenBuffers(1, &VBO[16]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[16]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices17), vertices17, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, stride, (void*)((3 + 3) * sizeof(float)));
    glEnableVertexAttribArray(2);

    unsigned texture1 = loadImageToTexture("res/am.png");
    glBindTexture(GL_TEXTURE_2D, texture1);
    glGenerateMipmap(GL_TEXTURE_2D);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glBindTexture(GL_TEXTURE_2D, 0);

    // FM
    float vertices18[] =
    {
        //X     Y      Z       NX    NY     NZ    S    T
         0.7001f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
         0.7001f, 0.0f, -0.1f, 1.0f, 0.0f, 0.0f, 1.0f, 0.0f,
         0.7001f, 0.1f, -0.1f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,
         0.7001f, 0.1f, -0.1f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f,
         0.7001f, 0.1f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 1.0f,
         0.7001f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.0f, 0.0f,
    };
    stride = (3 + 3 + 2) * sizeof(float);

    glGenVertexArrays(1, &VAO[17]);
    glBindVertexArray(VAO[17]);

    glGenBuffers(1, &VBO[17]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[17]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices18), vertices18, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, stride, (void*)((3 + 3) * sizeof(float)));
    glEnableVertexAttribArray(2);

    unsigned texture2 = loadImageToTexture("res/fm.png");
    glBindTexture(GL_TEXTURE_2D, texture2);
    glGenerateMipmap(GL_TEXTURE_2D);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glBindTexture(GL_TEXTURE_2D, 0);

    // VOLUME
    float vertices19[] =
    {
        //X     Y      Z       NX    NY     NZ    S    T
         0.0f, -0.05f, 0.4001f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
         0.6f, -0.05f, 0.4001f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f,
         0.6f, 0.05f, 0.4001f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
         0.6f, 0.05f, 0.4001f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f,
         0.0f, 0.05f, 0.4001f, 0.0f, 0.0f, 1.0f, 0.0f, 1.0f,
         0.0f, -0.05f, 0.4001f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f,
    };
    stride = (3 + 3 + 2) * sizeof(float);

    glGenVertexArrays(1, &VAO[18]);
    glBindVertexArray(VAO[18]);

    glGenBuffers(1, &VBO[18]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[18]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices19), vertices19, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, stride, (void*)((3 + 3) * sizeof(float)));
    glEnableVertexAttribArray(2);

    unsigned texture3 = loadImageToTexture("res/volume.png");
    glBindTexture(GL_TEXTURE_2D, texture3);
    glGenerateMipmap(GL_TEXTURE_2D);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glBindTexture(GL_TEXTURE_2D, 0);

    // INSTRUCTIONS
    float vertices20[] =
    {
        //X     Y      Z       NX    NY     NZ    S    T
         0.675f, -0.375f, -0.2001f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
         -0.675f, -0.375f, -0.2001f, 0.0f, 0.0f, -1.0f, 1.0f, 0.0f,
         -0.675f, 0.475f, -0.2001f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f,
         -0.675f, 0.475f, -0.2001f, 0.0f, 0.0f, -1.0f, 1.0f, 1.0f,
         0.675f, 0.475f, -0.2001f, 0.0f, 0.0f, -1.0f, 0.0f, 1.0f,
         0.675f, -0.375f, -0.2001f, 0.0f, 0.0f, -1.0f, 0.0f, 0.0f,
    };
    stride = (3 + 3 + 2) * sizeof(float);

    glGenVertexArrays(1, &VAO[19]);
    glBindVertexArray(VAO[19]);

    glGenBuffers(1, &VBO[19]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[19]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices20), vertices20, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, stride, (void*)((3 + 3) * sizeof(float)));
    glEnableVertexAttribArray(2);

    unsigned texture4 = loadImageToTexture("res/instructions.png");
    glBindTexture(GL_TEXTURE_2D, texture4);
    glGenerateMipmap(GL_TEXTURE_2D);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glBindTexture(GL_TEXTURE_2D, 0);

    // SIGNATURE
    float vertices21[] =
    {   //X    Y      S    T 
        0.0, 0.85, 0.0, 0.0,
        1.0, 0.85, 1.0, 0.0,
        1.0,  1.0, 1.0, 1.0,
        1.0,  1.0, 1.0, 1.0,
        0.0,  1.0, 0.0, 1.0,
        0.0, 0.85, 0.0, 0.0
    };
    stride = (2 + 2) * sizeof(float);

    glGenVertexArrays(1, &VAO[20]);
    glBindVertexArray(VAO[20]);

    glBindVertexArray(VAO[20]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[20]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices21), vertices21, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, stride, (void*)(2 * sizeof(float)));
    glEnableVertexAttribArray(1);

    unsigned texture5 = loadImageToTexture("res/signature.png");
    glBindTexture(GL_TEXTURE_2D, texture5);
    glGenerateMipmap(GL_TEXTURE_2D);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glBindTexture(GL_TEXTURE_2D, 0);

    // ONOFF LIGHT
    float vertices22[] =
    {
        //X     Y      Z       NX    NY     NZ
        -0.7375f, 0.43125, 0.10625, 0.0f, 0.0f, 1.0f,
        -0.725f, 0.43125, 0.10625, 0.0f, 0.0f, 1.0f,
        -0.725f, 0.44375, 0.10625, 0.0f, 0.0f, 1.0f,
        -0.725f, 0.44375, 0.10625, 0.0f, 0.0f, 1.0f,
        -0.7375f, 0.44375, 0.10625, 0.0f, 0.0f, 1.0f,
        -0.7375f, 0.43125, 0.10625, 0.0f, 0.0f, 1.0f,

        -0.725f, 0.43125, 0.09375, 0.0f, 0.0f, -1.0f,
        -0.7375f, 0.43125, 0.09375, 0.0f, 0.0f, -1.0f,
        -0.7375f, 0.44375, 0.09375, 0.0f, 0.0f, -1.0f,
        -0.7375f, 0.44375, 0.09375, 0.0f, 0.0f, -1.0f,
        -0.725f, 0.44375, 0.09375, 0.0f, 0.0f, -1.0f,
        -0.725f, 0.43125, 0.09375, 0.0f, 0.0f, -1.0f,

        -0.7375f, 0.43125, 0.09375, -1.0f, 0.0f, 0.0f,
        -0.7375f, 0.43125, 0.10625, -1.0f, 0.0f, 0.0f,
        -0.7375f, 0.44375, 0.10625, -1.0f, 0.0f, 0.0f,
        -0.7375f, 0.44375, 0.10625, -1.0f, 0.0f, 0.0f,
        -0.7375f, 0.44375, 0.09375, -1.0f, 0.0f, 0.0f,
        -0.7375f, 0.43125, 0.09375, -1.0f, 0.0f, 0.0f,

        -0.7375f, 0.44375, 0.10625, 0.0f, 1.0f, 0.0f,
        -0.725f, 0.44375, 0.10625, 0.0f, 1.0f, 0.0f,
        -0.725f, 0.44375, 0.09375, 0.0f, 1.0f, 0.0f,
        -0.725f, 0.44375, 0.09375, 0.0f, 1.0f, 0.0f,
        -0.7375f, 0.44375, 0.09375, 0.0f, 1.0f, 0.0f,
        -0.7375f, 0.44375, 0.10625, 0.0f, 1.0f, 0.0f,

        -0.7375f, 0.43125, 0.09375, 0.0f, -1.0f, 0.0f,
        -0.725f, 0.43125, 0.09375, 0.0f, -1.0f, 0.0f,
        -0.725f, 0.43125, 0.10625, 0.0f, -1.0f, 0.0f,
        -0.725f, 0.43125, 0.10625, 0.0f, -1.0f, 0.0f,
        -0.7375f, 0.43125, 0.10625, 0.0f, -1.0f, 0.0f,
        -0.7375f, 0.43125, 0.09375, 0.0f, -1.0f, 0.0f,
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[21]);
    glBindVertexArray(VAO[21]);
    glGenBuffers(1, &VBO[21]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[21]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices22), vertices22, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    // ANTENNA LIGHT
    float vertices23[] =
    {   //X     Y      Z       NX    NY     NZ
        -0.575f, 1.2125f, 0.125f,  0.0f,  0.0f,  1.0f,
         -0.525f, 1.2125f, 0.125f,  0.0f,  0.0f,  1.0f,
         -0.525f, 1.225f,  0.125f,  0.0f,  0.0f,  1.0f,
         -0.525f, 1.225f,  0.125f,  0.0f,  0.0f,  1.0f,
        -0.575f, 1.225f,  0.125f,  0.0f,  0.0f,  1.0f,
        -0.575f, 1.2125f, 0.125f,  0.0f,  0.0f,  1.0f,

        -0.525f, 1.2125f, 0.075f, 0.0f, 0.0f, -1.0f,
        -0.575f, 1.2125f, 0.075f, 0.0f, 0.0f, -1.0f,
        -0.575f, 1.225f, 0.075f, 0.0f, 0.0f, -1.0f,
        -0.575f, 1.225f, 0.075f, 0.0f, 0.0f, -1.0f,
        -0.525f, 1.225f, 0.075f, 0.0f, 0.0f, -1.0f,
        -0.525f, 1.2125f, 0.075f, 0.0f, 0.0f, -1.0f,

        -0.575f, 1.2125f, 0.075f, -1.0f, 0.0f, 0.0f,
        -0.575f, 1.2125f, 0.125f, -1.0f, 0.0f, 0.0f,
        -0.575f, 1.225f, 0.125f, -1.0f, 0.0f, 0.0f,
        -0.575f, 1.225f, 0.125f, -1.0f, 0.0f, 0.0f,
        -0.575f, 1.225f, 0.075f, -1.0f, 0.0f, 0.0f,
        -0.575f, 1.2125f, 0.075f, -1.0f, 0.0f, 0.0f,

        -0.525f, 1.2125f, 0.125f, 1.0f, 0.0f, 0.0f,
        -0.525f, 1.2125f, 0.075f, 1.0f, 0.0f, 0.0f,
        -0.525f, 1.225f, 0.075f, 1.0f, 0.0f, 0.0f,
        -0.525f, 1.225f, 0.075f, 1.0f, 0.0f, 0.0f,
        -0.525f, 1.225f, 0.125f, 1.0f, 0.0f, 0.0f,
        -0.525f, 1.2125f, 0.125f, 1.0f, 0.0f, 0.0f,

        -0.575f, 1.225f, 0.125f, 0.0f, 1.0f, 0.0f,
        -0.525f, 1.225f, 0.125f, 0.0f, 1.0f, 0.0f,
        -0.525f, 1.225f, 0.075f, 0.0f, 1.0f, 0.0f,
        -0.525f, 1.225f, 0.075f, 0.0f, 1.0f, 0.0f,
        -0.575f, 1.225f, 0.075f, 0.0f, 1.0f, 0.0f,
        -0.575f, 1.225f, 0.125f, 0.0f, 1.0f, 0.0f
    };
    stride = (3 + 3) * sizeof(float);

    glGenVertexArrays(1, &VAO[22]);
    glBindVertexArray(VAO[22]);

    glGenBuffers(1, &VBO[22]);
    glBindBuffer(GL_ARRAY_BUFFER, VBO[22]);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices23), vertices23, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, stride, (void*)0);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, stride, (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++ SHADERS +++++++++++++++++++++++++++++++++++++++++++++++++
    Shader radioShader("phong.vert", "phong.frag");
    Shader speakerBoxShader("phong.vert", "phong.frag");
    Shader antennaBottomShader("phong.vert", "phong.frag");
    Shader antennaTopShader("phong.vert", "phong.frag");
    Shader amfmSwitchShader("phong.vert", "phong.frag");
    Shader onoffSwitchShader("phong.vert", "phong.frag");
    Shader volumeSwitchShader("phong.vert", "phong.frag");
    Shader volumeBarShader("phong.vert", "light.frag");
    Shader scaleShader("phong.vert", "phong.frag");
    Shader numberScaleShader("phong.vert", "phong.frag");
    Shader arrowShader("phong.vert", "phong.frag");
    Shader controlKnobShader("phong.vert", "phong.frag");
    Shader knobArrowShader("phong.vert", "phong.frag");
    Shader membraneShader("phong.vert", "phong.frag");
    Shader speakerShader("phong.vert", "phong.frag");
    Shader meshShader("phong.vert", "phong.frag");
    Shader amShader("texture.vert", "texture.frag");
    Shader fmShader("texture.vert", "texture.frag");
    Shader volumeShader("texture.vert", "texture.frag");
    Shader instructionsShader("texture.vert", "texture.frag");
    Shader signatureShader("signature.vert", "signature.frag");
    Shader onoffLightShader("phong.vert", "light.frag");
    Shader antennaLightShader("phong.vert", "light.frag");

    // ++++++++++++++++++++++++++++++++++++++++++++++++++++++ RENDER LOOP +++++++++++++++++++++++++++++++++++++++++++++++++
    radioShader.use();
    radioShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    radioShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    radioShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    radioShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    radioShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    radioShader.setVec3("uPointLights[0].kA", 0.0, 0.001, 0.0);
    radioShader.setVec3("uPointLights[0].kD", 0.0, 0.8, 0.0);
    radioShader.setVec3("uPointLights[0].kS", 0.0, 1.0, 0.0);
    radioShader.setFloat("uPointLights[0].constant", 1.0);
    radioShader.setFloat("uPointLights[0].linear", 0.01);
    radioShader.setFloat("uPointLights[0].quadratic", 0.001);
    radioShader.setVec3("uSpotLight.pos", glm::vec3(-0.55f, 1.21875f, 0.1f));
    radioShader.setVec3("uSpotLight.dir", glm::vec3(0.0f, 1.0f, 0.0f));
    radioShader.setFloat("uSpotLight.cutOff", glm::cos(glm::radians(25.0f)));
    radioShader.setFloat("uSpotLight.outerCutOff", glm::cos(glm::radians(30.0f)));
    radioShader.setVec3("uSpotLight.kA", 0.01, 0.01, 0.01);
    radioShader.setVec3("uSpotLight.kD", 0.8, 0.8, 0.8);
    radioShader.setVec3("uSpotLight.kS", 1.0, 1.0, 1.0);
    radioShader.setFloat("uSpotLight.constant", 1.0);
    radioShader.setFloat("uSpotLight.linear", 0.09);
    radioShader.setFloat("uSpotLight.quadratic", 0.032);
    radioShader.setFloat("uMaterial.shine", 0.8 * 128);
    radioShader.setVec3("uMaterial.kA", 0.25, 0.25, 0.25);
    radioShader.setVec3("uMaterial.kD", 0.4, 0.4, 0.4);
    radioShader.setVec3("uMaterial.kS", 0.2, 0.2, 0.2);
    radioShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 radioModel = glm::mat4(1.0f);

    speakerBoxShader.use();
    speakerBoxShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    speakerBoxShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    speakerBoxShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    speakerBoxShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    speakerBoxShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    speakerBoxShader.setFloat("uMaterial.shine", 0.4 * 128);
    speakerBoxShader.setVec3("uMaterial.kA", 0.1, 0.1, 0.1);
    speakerBoxShader.setVec3("uMaterial.kD", 0.2, 0.2, 0.2);
    speakerBoxShader.setVec3("uMaterial.kS", 0.05, 0.05, 0.05);
    speakerBoxShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 speakerBoxModel = glm::mat4(1.0f);

    antennaBottomShader.use();
    antennaBottomShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    antennaBottomShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    antennaBottomShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    antennaBottomShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    antennaBottomShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    antennaBottomShader.setFloat("uMaterial.shine", 1 * 128);
    antennaBottomShader.setVec3("uMaterial.kA", 0.4, 0.4, 0.4);
    antennaBottomShader.setVec3("uMaterial.kD", 0.8, 0.8, 0.8);
    antennaBottomShader.setVec3("uMaterial.kS", 0.3, 0.3, 0.3);
    antennaBottomShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 antennaBottomModel = glm::mat4(1.0f);

    antennaTopShader.use();
    antennaTopShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    antennaTopShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    antennaTopShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    antennaTopShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    antennaTopShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    antennaTopShader.setFloat("uMaterial.shine", 1 * 128);
    antennaTopShader.setVec3("uMaterial.kA", 0.4, 0.4, 0.4);
    antennaTopShader.setVec3("uMaterial.kD", 0.8, 0.8, 0.8);
    antennaTopShader.setVec3("uMaterial.kS", 0.3, 0.3, 0.3);
    antennaTopShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 antennaTopModel = glm::mat4(1.0f);

    amfmSwitchShader.use();
    amfmSwitchShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    amfmSwitchShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    amfmSwitchShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    amfmSwitchShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    amfmSwitchShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    amfmSwitchShader.setFloat("uMaterial.shine", 0.4 * 128);
    amfmSwitchShader.setVec3("uMaterial.kA", 0.05, 0.05, 0.05);
    amfmSwitchShader.setVec3("uMaterial.kD", 0.1, 0.1, 0.1);
    amfmSwitchShader.setVec3("uMaterial.kS", 0.025, 0.025, 0.025);
    amfmSwitchShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 amfmSwitchModel = glm::mat4(1.0f);

    onoffSwitchShader.use();
    onoffSwitchShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    onoffSwitchShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    onoffSwitchShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    onoffSwitchShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    onoffSwitchShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    onoffSwitchShader.setFloat("uMaterial.shine", 0.4 * 128);
    onoffSwitchShader.setVec3("uMaterial.kA", 0.05, 0.05, 0.05);
    onoffSwitchShader.setVec3("uMaterial.kD", 0.1, 0.1, 0.1);
    onoffSwitchShader.setVec3("uMaterial.kS", 0.025, 0.025, 0.025);
    onoffSwitchShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 onoffSwitchModel = glm::mat4(1.0f);

    volumeSwitchShader.use();
    volumeSwitchShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    volumeSwitchShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    volumeSwitchShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    volumeSwitchShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    volumeSwitchShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    volumeSwitchShader.setFloat("uMaterial.shine", 0.4 * 128);
    volumeSwitchShader.setVec3("uMaterial.kA", 0.05, 0.05, 0.05);
    volumeSwitchShader.setVec3("uMaterial.kD", 0.1, 0.1, 0.1);
    volumeSwitchShader.setVec3("uMaterial.kS", 0.025, 0.025, 0.025);
    volumeSwitchShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 volumeSwitchModel = glm::mat4(1.0f);

    volumeBarShader.use();
    volumeBarShader.setFloat("mShine", 0.4 * 128);
    volumeBarShader.setVec3("mKA", 0.0, 0.5, 0.0);
    volumeBarShader.setVec3("mKD", 0.0, 0.5, 0.0);
    volumeBarShader.setVec3("mKS", 0.0, 0.5, 0.0);
    volumeBarShader.setVec3("mKE", 0.0, 1.0, 0.0);
    volumeBarShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 volumeBarModel = glm::mat4(1.0f);

    scaleShader.use();
    scaleShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    scaleShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    scaleShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    scaleShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    scaleShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    scaleShader.setFloat("uMaterial.shine", 0.4 * 128);
    scaleShader.setVec3("uMaterial.kA", 0.9, 0.9, 0.9);
    scaleShader.setVec3("uMaterial.kD", 0.95, 0.95, 0.95);
    scaleShader.setVec3("uMaterial.kS", 0.85, 0.85, 0.85);
    scaleShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 scaleModel = glm::mat4(1.0f);

    numberScaleShader.use();
    numberScaleShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    numberScaleShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    numberScaleShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    numberScaleShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    numberScaleShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    numberScaleShader.setFloat("uMaterial.shine", 0.4 * 128);
    numberScaleShader.setVec3("uMaterial.kA", 0.05, 0.05, 0.05);
    numberScaleShader.setVec3("uMaterial.kD", 0.1, 0.1, 0.1);
    numberScaleShader.setVec3("uMaterial.kS", 0.0, 0.0, 0.0);
    numberScaleShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 numberScaleModel = glm::mat4(1.0f);

    arrowShader.use();
    arrowShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    arrowShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    arrowShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    arrowShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    arrowShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    arrowShader.setFloat("uMaterial.shine", 0.4 * 128);
    arrowShader.setVec3("uMaterial.kA", 0.9, 0.0, 0.0);
    arrowShader.setVec3("uMaterial.kD", 0.95, 0.0, 0.0);
    arrowShader.setVec3("uMaterial.kS", 0.85, 0.0, 0.0);
    arrowShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 arrowModel = glm::mat4(1.0f);

    controlKnobShader.use();
    controlKnobShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    controlKnobShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    controlKnobShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    controlKnobShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    controlKnobShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    controlKnobShader.setFloat("uMaterial.shine", 0.8 * 128);
    controlKnobShader.setVec3("uMaterial.kA", 0.25, 0.25, 0.25);
    controlKnobShader.setVec3("uMaterial.kD", 0.4, 0.4, 0.4);
    controlKnobShader.setVec3("uMaterial.kS", 0.2, 0.2, 0.2);
    controlKnobShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 controlKnobModel = glm::mat4(1.0f);

    knobArrowShader.use();
    knobArrowShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    knobArrowShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    knobArrowShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    knobArrowShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    knobArrowShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    knobArrowShader.setFloat("uMaterial.shine", 0.4 * 128);
    knobArrowShader.setVec3("uMaterial.kA", 0.1, 0.1, 0.1);
    knobArrowShader.setVec3("uMaterial.kD", 0.2, 0.2, 0.2);
    knobArrowShader.setVec3("uMaterial.kS", 0.05, 0.05, 0.05);
    knobArrowShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 knobArrowModel = glm::mat4(1.0f);

    membraneShader.use();
    membraneShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    membraneShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    membraneShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    membraneShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    membraneShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    membraneShader.setFloat("uMaterial.shine", 0.4 * 128);
    membraneShader.setVec3("uMaterial.kA", 0.05, 0.05, 0.05);
    membraneShader.setVec3("uMaterial.kD", 0.1, 0.1, 0.1);
    membraneShader.setVec3("uMaterial.kS", 0.0, 0.0, 0.0);
    membraneShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 membraneModel = glm::mat4(1.0f);

    speakerShader.use();
    speakerShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    speakerShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    speakerShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    speakerShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    speakerShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    speakerShader.setFloat("uMaterial.shine", 0.4 * 128);
    speakerShader.setVec3("uMaterial.kA", 0.1, 0.1, 0.1);
    speakerShader.setVec3("uMaterial.kD", 0.2, 0.2, 0.2);
    speakerShader.setVec3("uMaterial.kS", 0.05, 0.05, 0.05);
    speakerShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 speakerModel = glm::mat4(1.0f);

    meshShader.use();
    meshShader.setVec3("uDirLights[0].dir", 0.0, -0.25, -2.0);
    meshShader.setVec3("uDirLights[0].kA", 0.4, 0.4, 0.4);
    meshShader.setVec3("uDirLights[0].kD", 0.8, 0.8, 0.8);
    meshShader.setVec3("uDirLights[0].kS", 1.0, 1.0, 1.0);
    meshShader.setVec3("uPointLights[0].pos", -0.8f, 0.4375, 0.1);
    meshShader.setFloat("uMaterial.shine", 0.4 * 128);
    meshShader.setVec3("uMaterial.kA", 0.05, 0.05, 0.05);
    meshShader.setVec3("uMaterial.kD", 0.1, 0.1, 0.1);
    meshShader.setVec3("uMaterial.kS", 0.0, 0.0, 0.0);
    meshShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 meshModel = glm::mat4(1.0f);

    amShader.use();
    amShader.setVec3("lPos", 0.0, 0.25, 2.0);
    amShader.setVec3("lKA", 0.4, 0.4, 0.4);
    amShader.setVec3("lKD", 0.8, 0.8, 0.8);
    amShader.setVec3("lKS", 1.0, 1.0, 1.0);
    amShader.setFloat("mShine", 0.5 * 128);
    amShader.setVec3("mKA", 0.5, 0.5, 0.5);
    amShader.setVec3("mKD", 0.5, 0.5, 0.5);
    amShader.setVec3("mKS", 0.5, 0.5, 0.5);
    glm::mat4 amModel = glm::mat4(1.0f);

    fmShader.use();
    fmShader.setVec3("lPos", 0.0, 0.25, 2.0);
    fmShader.setVec3("lKA", 0.4, 0.4, 0.4);
    fmShader.setVec3("lKD", 0.8, 0.8, 0.8);
    fmShader.setVec3("lKS", 1.0, 1.0, 1.0);
    fmShader.setFloat("mShine", 0.5 * 128);
    fmShader.setVec3("mKA", 0.5, 0.5, 0.5);
    fmShader.setVec3("mKD", 0.5, 0.5, 0.5);
    fmShader.setVec3("mKS", 0.5, 0.5, 0.5);
    glm::mat4 fmModel = glm::mat4(1.0f);

    volumeShader.use();
    volumeShader.setVec3("lPos", 0.0, 0.25, 2.0);
    volumeShader.setVec3("lKA", 0.4, 0.4, 0.4);
    volumeShader.setVec3("lKD", 0.8, 0.8, 0.8);
    volumeShader.setVec3("lKS", 1.0, 1.0, 1.0);
    volumeShader.setFloat("mShine", 0.5 * 128);
    volumeShader.setVec3("mKA", 0.5, 0.5, 0.5);
    volumeShader.setVec3("mKD", 0.5, 0.5, 0.5);
    volumeShader.setVec3("mKS", 0.5, 0.5, 0.5);
    glm::mat4 volumeModel = glm::mat4(1.0f);

    instructionsShader.use();
    instructionsShader.setVec3("lPos", 0.0, 0.25, 2.0);
    instructionsShader.setVec3("lKA", 0.4, 0.4, 0.4);
    instructionsShader.setVec3("lKD", 0.8, 0.8, 0.8);
    instructionsShader.setVec3("lKS", 1.0, 1.0, 1.0);
    instructionsShader.setFloat("mShine", 0.5 * 128);
    instructionsShader.setVec3("mKA", 0.5, 0.5, 0.5);
    instructionsShader.setVec3("mKD", 0.5, 0.5, 0.5);
    instructionsShader.setVec3("mKS", 0.5, 0.5, 0.5);
    glm::mat4 instructionsModel = glm::mat4(1.0f);

    signatureShader.use();
    signatureShader.setVec3("lPos", 0.0, 0.25, 2.0);
    signatureShader.setVec3("lKA", 0.4, 0.4, 0.4);
    signatureShader.setVec3("lKD", 0.8, 0.8, 0.8);
    signatureShader.setVec3("lKS", 1.0, 1.0, 1.0);
    signatureShader.setFloat("mShine", 0.5 * 128);
    signatureShader.setVec3("mKA", 0.5, 0.5, 0.5);
    signatureShader.setVec3("mKD", 0.5, 0.5, 0.5);
    signatureShader.setVec3("mKS", 0.5, 0.5, 0.5);
    glm::mat4 signatureModel = glm::mat4(1.0f);

    onoffLightShader.use();
    onoffLightShader.setVec3("lPos", 0.0, 0.25, 2.0);
    onoffLightShader.setVec3("lKA", 0.4, 0.4, 0.4);
    onoffLightShader.setVec3("lKD", 0.8, 0.8, 0.8);
    onoffLightShader.setVec3("lKS", 1.0, 1.0, 1.0);
    onoffLightShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 onoffLightModel = glm::mat4(1.0f);

    antennaLightShader.use();
    antennaLightShader.setVec3("lPos", 0.0, 0.25, 2.0);
    antennaLightShader.setVec3("lKA", 0.4, 0.4, 0.4);
    antennaLightShader.setVec3("lKD", 0.8, 0.8, 0.8);
    antennaLightShader.setVec3("lKS", 1.0, 1.0, 1.0);
    antennaLightShader.setVec3("uViewPos", 0.0, 0.0, 2.0);
    glm::mat4 antennaLightModel = glm::mat4(1.0f);

    float modelRotationX = 0.0f;
    float modelRotationY = 0.0f;
    float modelRotationZ = 0.0f;

    glm::vec3 antennaTopRotationPoint(-0.55f, 0.828125f, 0.1f);
    float antennaTopRotation = 0.0f;

    glm::vec3 antennaRotationPoint(-0.55f, 0.0f, 0.1f);
    float antennaRotation = 0.0f;

    float antennaTranslation = 0.0f;

    bool isOn = false;

    float volume = 0.0f;

    float frequency = 0.0f;

    glm::vec3 knobArrowRotationPoint(0.7f, 0.3f, 0.1f);

    float membraneScalingFactor = 1.0f;

    glm::mat4 modelRotationMatrixX;
    glm::mat4 modelRotationMatrixY;
    glm::mat4 modelRotationMatrixZ;

    glm::mat4 rotationMatrix;
    glm::mat4 translationMatrix;
    glm::mat4 translationToOriginMatrix;
    glm::mat4 translationBackMatrix;
    glm::mat4 scalingMatrix;

    
    glEnable(GL_DEPTH_TEST);
    while (!glfwWindowShouldClose(window))
    {
        glClearColor(0.7, 0.7, 0.7, 1.0);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        if (glfwGetKey(window, GLFW_KEY_KP_ADD) == GLFW_PRESS)
        {
            cameraPosition -= zoomSpeed * glm::normalize(glm::vec3(view[0][2], view[1][2], view[2][2]));
        }
        else if (glfwGetKey(window, GLFW_KEY_KP_SUBTRACT) == GLFW_PRESS)
        {
            cameraPosition += zoomSpeed * glm::normalize(glm::vec3(view[0][2], view[1][2], view[2][2]));
        }
        view = glm::lookAt(cameraPosition, glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f));
        radioShader.use();
        radioShader.setMat4("uV", view);
        radioShader.setMat4("uP", projection);
        speakerBoxShader.use();
        speakerBoxShader.setMat4("uV", view);
        speakerBoxShader.setMat4("uP", projection);
        antennaBottomShader.use();
        antennaBottomShader.setMat4("uV", view);
        antennaBottomShader.setMat4("uP", projection);
        antennaTopShader.use();
        antennaTopShader.setMat4("uV", view);
        antennaTopShader.setMat4("uP", projection);
        amfmSwitchShader.use();
        amfmSwitchShader.setMat4("uV", view);
        amfmSwitchShader.setMat4("uP", projection);
        onoffSwitchShader.use();
        onoffSwitchShader.setMat4("uV", view);
        onoffSwitchShader.setMat4("uP", projection);
        volumeSwitchShader.use();
        volumeSwitchShader.setMat4("uV", view);
        volumeSwitchShader.setMat4("uP", projection);
        volumeBarShader.use();
        volumeBarShader.setMat4("uV", view);
        volumeBarShader.setMat4("uP", projection);
        scaleShader.use();
        scaleShader.setMat4("uV", view);
        scaleShader.setMat4("uP", projection);
        numberScaleShader.use();
        numberScaleShader.setMat4("uV", view);
        numberScaleShader.setMat4("uP", projection);
        arrowShader.use();
        arrowShader.setMat4("uV", view);
        arrowShader.setMat4("uP", projection);
        controlKnobShader.use();
        controlKnobShader.setMat4("uV", view);
        controlKnobShader.setMat4("uP", projection);
        knobArrowShader.use();
        knobArrowShader.setMat4("uV", view);
        knobArrowShader.setMat4("uP", projection);
        membraneShader.use();
        membraneShader.setMat4("uV", view);
        membraneShader.setMat4("uP", projection);
        speakerShader.use();
        speakerShader.setMat4("uV", view);
        speakerShader.setMat4("uP", projection);
        meshShader.use();
        meshShader.setMat4("uV", view);
        meshShader.setMat4("uP", projection);
        amShader.use();
        amShader.setMat4("uV", view);
        amShader.setMat4("uP", projection);
        fmShader.use();
        fmShader.setMat4("uV", view);
        fmShader.setMat4("uP", projection);
        volumeShader.use();
        volumeShader.setMat4("uV", view);
        volumeShader.setMat4("uP", projection);
        instructionsShader.use();
        instructionsShader.setMat4("uV", view);
        instructionsShader.setMat4("uP", projection);
        signatureShader.use();
        signatureShader.setMat4("uV", view);
        signatureShader.setMat4("uP", projection);
        onoffLightShader.use();
        onoffLightShader.setMat4("uV", view);
        onoffLightShader.setMat4("uP", projection);
        antennaLightShader.use();
        antennaLightShader.setMat4("uV", view);
        antennaLightShader.setMat4("uP", projection);

        if (glfwGetKey(window, GLFW_KEY_W) == GLFW_PRESS)
        {
            modelRotationX = modelRotationX - 0.5f;
        }
        else if (glfwGetKey(window, GLFW_KEY_S) == GLFW_PRESS)
        {
            modelRotationX = modelRotationX + 0.5f;
        }
        else if (glfwGetKey(window, GLFW_KEY_A) == GLFW_PRESS)
        {
            modelRotationY = modelRotationY - 0.5f;
        }
        else if (glfwGetKey(window, GLFW_KEY_D) == GLFW_PRESS)
        {
            modelRotationY = modelRotationY + 0.5f;
        }
        else if (glfwGetKey(window, GLFW_KEY_Q) == GLFW_PRESS)
        {
            modelRotationZ = modelRotationZ - 0.5f;
        }
        else if (glfwGetKey(window, GLFW_KEY_E) == GLFW_PRESS)
        {
            modelRotationZ = modelRotationZ + 0.5f;
        }
        modelRotationMatrixX = glm::rotate(glm::mat4(1.0f), glm::radians(modelRotationX), glm::vec3(1.0f, 0.0f, 0.0f));
        modelRotationMatrixY = glm::rotate(glm::mat4(1.0f), glm::radians(modelRotationY), glm::vec3(0.0f, 1.0f, 0.0f));
        modelRotationMatrixZ = glm::rotate(glm::mat4(1.0f), glm::radians(modelRotationZ), glm::vec3(0.0f, 0.0f, 1.0f));

        if (resetAntenna) {
            if (-0.5f < antennaTopRotation && antennaTopRotation < 0.5f) {
                antennaTopRotation = 0;
                resetAntenna = false;
            }
            else if (antennaTopRotation <= -0.5f) {
                antennaTopRotation += 0.5f;
            }
            else if (antennaTopRotation >= 0.5f) {
                antennaTopRotation -= 0.5f;
            }
        }
        else {
            if (glfwGetKey(window, GLFW_KEY_Z) == GLFW_PRESS)
            {
                antennaTopRotation = antennaTopRotation < -99.5f ? -100.0f : (antennaTopRotation - 0.5f);
                antennaTopRotation = antennaTranslation < -0.2 ? 0.0f : antennaTopRotation;
            }
            else if (glfwGetKey(window, GLFW_KEY_X) == GLFW_PRESS)
            {
                antennaTopRotation = antennaTopRotation > 99.5f ? 100.0f : (antennaTopRotation + 0.5f);
                antennaTopRotation = antennaTranslation < -0.2 ? 0.0f : antennaTopRotation;
            }
            else if (glfwGetKey(window, GLFW_KEY_C) == GLFW_PRESS)
            {
                antennaRotation = std::fmod(antennaRotation - 0.5f, 360.0f);
            }
            else if (glfwGetKey(window, GLFW_KEY_V) == GLFW_PRESS)
            {
                antennaRotation = std::fmod(antennaRotation + 0.5f, 360.0f);
            }
            else if (glfwGetKey(window, GLFW_KEY_B) == GLFW_PRESS)
            {
                antennaTranslation = antennaTranslation < -0.599f ? -0.6f : (antennaTranslation - 0.001f);
                antennaTranslation = antennaTopRotation != 0.0 && antennaTranslation < -0.2f ? -0.2f : antennaTranslation;
            }
            else if (glfwGetKey(window, GLFW_KEY_N) == GLFW_PRESS)
            {
                antennaTranslation = antennaTranslation > -0.001f ? 0.0f : (antennaTranslation + 0.001f);
                antennaTranslation = antennaTopRotation != 0.0 && antennaTranslation < -0.2f ? -0.2f : antennaTranslation;
            }
        }

        if (switchRegime) {
            amfmSwitchTranslation = switchRegime == 1 ? amfmSwitchTranslation - 0.001f : amfmSwitchTranslation + 0.001f;
            if (amfmSwitchTranslation < 0.0005f)
            {
                amfmSwitchTranslation = 0.0f;
                switchRegime = 0;
            }
            if (0.0995f < amfmSwitchTranslation)
            {
                amfmSwitchTranslation = 0.1f;
                switchRegime = 0;
            }
        }

        if (switchPower) {
            onoffSwitchTranslation = switchPower == 1 ? onoffSwitchTranslation - 0.0005f : onoffSwitchTranslation + 0.0005f;
            if (onoffSwitchTranslation < 0.00025f)
            {
                onoffSwitchTranslation = 0.0f;
                switchPower = 0;
                isOn = false;
            }
            if (0.02475f < onoffSwitchTranslation)
            {
                onoffSwitchTranslation = 0.025f;
                switchPower = 0;
                isOn = true;
            }
        }

        if (glfwGetKey(window, GLFW_KEY_UP) == GLFW_PRESS)
        {
            volume = (volume + 0.001f) > 1.0f ? 1.0f : (volume + 0.001f);
        }
        else if (glfwGetKey(window, GLFW_KEY_DOWN) == GLFW_PRESS)
        {
            volume = (volume - 0.001f) < 0.0f ? 0.0f : (volume - 0.001f);
        }

        if (glfwGetKey(window, GLFW_KEY_RIGHT) == GLFW_PRESS)
        {
            frequency = (frequency + 0.001f) > 1.0f ? 1.0f : (frequency + 0.001f);
        }
        else if (glfwGetKey(window, GLFW_KEY_LEFT) == GLFW_PRESS)
        {
            frequency = (frequency - 0.001f) < 0.0f ? 0.0f : (frequency - 0.001f);
        }

        membraneScalingFactor = isOn ? 1.0f + volume * 0.0625 / 2 * (1 - sin(glfwGetTime() * 25)) : 1.0f;

        // RADIO 
        radioShader.use();
        glm::vec3 originalSpotlightPos = glm::vec3(-0.55f, 1.21875f, 0.1f);
        glm::vec3 originalSpotlightDir = glm::vec3(0.0f, 1.0f, 0.0f);
        radioShader.setBool("hasPointLight", isOn ? true : false);
        radioShader.setVec3("uPointLights[0].pos", modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * glm::vec4(-0.73125f, 0.4375f, 0.1f, 1.0f));
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(antennaTopRotation), glm::vec3(1.0f, 0.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -antennaTopRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), antennaTopRotationPoint);
        antennaLightModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix;
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(antennaRotation), glm::vec3(0.0f, 1.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -antennaRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), antennaRotationPoint);
        antennaLightModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix * antennaLightModel;
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, antennaTranslation, 0.0f));
        antennaLightModel = translationMatrix * antennaLightModel;
        antennaLightModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * antennaLightModel;
        glm::vec4 transformedSpotlightPos = antennaLightModel * glm::vec4(originalSpotlightPos, 1.0f);
        glm::mat3 rotationMatrixOnly = glm::mat3(antennaLightModel);
        glm::vec3 transformedSpotlightDir = rotationMatrixOnly * originalSpotlightDir;
        radioShader.setVec3("uSpotLight.pos", transformedSpotlightPos.x, transformedSpotlightPos.y, transformedSpotlightPos.z);
        radioShader.setVec3("uSpotLight.dir", transformedSpotlightDir.x, transformedSpotlightDir.y, transformedSpotlightDir.z);
        radioShader.setBool("hasSpotLight", isOn ? true : false);
        radioModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        radioShader.setMat4("uM", radioModel);
        glBindVertexArray(VAO[0]);
        glDrawArrays(GL_TRIANGLES, 0, 144);

        // SPEAKER BOX
        speakerBoxShader.use();
        speakerBoxModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        speakerBoxShader.setMat4("uM", speakerBoxModel);
        glBindVertexArray(VAO[1]);
        glDrawArrays(GL_TRIANGLES, 0, 204);

        // ANTHENA BOTTOM
        antennaBottomShader.use();
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(antennaRotation), glm::vec3(0.0f, 1.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -antennaRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), antennaRotationPoint);
        antennaBottomModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix;
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, antennaTranslation, 0.0f));
        antennaBottomModel = translationMatrix * antennaBottomModel;
        antennaBottomModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * antennaBottomModel;
        antennaBottomShader.setMat4("uM", antennaBottomModel);
        glBindVertexArray(VAO[2]);
        glDrawArrays(GL_TRIANGLES, 0, 102);

        // ANTHENA TOP
        antennaTopShader.use();
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(antennaTopRotation), glm::vec3(1.0f, 0.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -antennaTopRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), antennaTopRotationPoint);
        antennaTopModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix;
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(antennaRotation), glm::vec3(0.0f, 1.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -antennaRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), antennaRotationPoint);
        antennaTopModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix * antennaTopModel;
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, antennaTranslation, 0.0f));
        antennaTopModel = translationMatrix * antennaTopModel;
        antennaTopModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * antennaTopModel;
        antennaTopShader.setMat4("uM", antennaTopModel);
        glBindVertexArray(VAO[3]);
        glDrawArrays(GL_TRIANGLES, 0, 114);

        // AMFM SWITCH
        amfmSwitchShader.use();
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, amfmSwitchTranslation));
        amfmSwitchModel = translationMatrix;
        amfmSwitchModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * amfmSwitchModel;
        amfmSwitchShader.setMat4("uM", amfmSwitchModel);
        glBindVertexArray(VAO[4]);
        glDrawArrays(GL_TRIANGLES, 0, 30);

        // ONOFF SWITCH
        onoffSwitchShader.use();
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, 0.0f, -onoffSwitchTranslation));
        onoffSwitchModel = translationMatrix;
        onoffSwitchModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * onoffSwitchModel;
        onoffSwitchShader.setMat4("uM", onoffSwitchModel);
        glBindVertexArray(VAO[5]);
        glDrawArrays(GL_TRIANGLES, 0, 30);

        // VOLUME SWITCH
        volumeSwitchShader.use();
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3((volume) * 0.5f, 0.0f, 0.0));
        volumeSwitchModel = translationMatrix;
        volumeSwitchModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * volumeSwitchModel;
        volumeSwitchShader.setMat4("uM", volumeSwitchModel);
        glBindVertexArray(VAO[6]);
        glDrawArrays(GL_TRIANGLES, 0, 30);

        // VOLUME BAR
        if(isOn && volume > 0.0f)
        {
            volumeBarShader.use();
            translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(isOn ? (volume) * 0.6f : 0.0f, 0.0f, 0.0));
            volumeBarModel = translationMatrix;
            volumeBarModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * volumeBarModel;
            volumeBarShader.setMat4("uM", volumeBarModel);
            glBindVertexArray(VAO[7]);
            glDrawArrays(GL_TRIANGLES, 0, 6);
        }

        // SCALE
        scaleShader.use();
        scaleModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        scaleShader.setMat4("uM", scaleModel);
        glBindVertexArray(VAO[8]);
        glDrawArrays(GL_TRIANGLES, 0, 6);

        // NUMBER SCALE
        numberScaleShader.use();
        numberScaleModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        numberScaleShader.setMat4("uM", numberScaleModel);
        glBindVertexArray(VAO[9]);
        glDrawArrays(GL_TRIANGLES, 0, 120);

        // ARROW
        arrowShader.use();
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3((frequency) * 0.9f, 0.0f, 0.0));
        arrowModel = translationMatrix;
        arrowModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * arrowModel;
        arrowShader.setMat4("uM", arrowModel);
        glBindVertexArray(VAO[10]);
        glDrawArrays(GL_TRIANGLES, 0, 3);

        // CONTROL KNOB 
        controlKnobShader.use();
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
        controlKnobModel = rotationMatrix;
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.8f, 0.3f, 0.1));
        controlKnobModel = translationMatrix * controlKnobModel;
        controlKnobModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * controlKnobModel;
        controlKnobShader.setMat4("uM", controlKnobModel);
        glBindVertexArray(VAO[11]);
        glDrawArrays(GL_TRIANGLES, 0, vertices12.size() / 6);

        // KNOB ARROW
        knobArrowShader.use();
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(frequency * 360.0f), glm::vec3(-1.0f, 0.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -knobArrowRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), knobArrowRotationPoint);
        knobArrowModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix;
        knobArrowModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * knobArrowModel;
        knobArrowShader.setMat4("uM", knobArrowModel);
        glBindVertexArray(VAO[12]);
        glDrawArrays(GL_TRIANGLES, 0, 36);

        // MEMBRANE
        membraneShader.use();
        scalingMatrix = glm::scale(glm::mat4(1.0f), glm::vec3(membraneScalingFactor, membraneScalingFactor, membraneScalingFactor));
        membraneModel = scalingMatrix;
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
        membraneModel = rotationMatrix * membraneModel;
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(-0.35f, 0.0f, 0.305f));
        membraneModel = translationMatrix * membraneModel;
        membraneModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * membraneModel;
        membraneShader.setMat4("uM", membraneModel);
        glBindVertexArray(VAO[13]);
        glDrawArrays(GL_TRIANGLES, 0, vertices14.size() / 6);

        // SPEAKER
        speakerShader.use();
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(90.0f), glm::vec3(1.0f, 0.0f, 0.0f));
        speakerModel = rotationMatrix;
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(-0.35f, 0.0f, 0.325f));
        speakerModel = translationMatrix * speakerModel;
        speakerModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * speakerModel;
        speakerShader.setMat4("uM", speakerModel);
        glBindVertexArray(VAO[14]);
        glDrawArrays(GL_TRIANGLES, 0, vertices15.size() / 6);

        // MESH
        meshShader.use();
        meshModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        meshShader.setMat4("uM", meshModel);
        glBindVertexArray(VAO[15]);
        glDrawArrays(GL_TRIANGLES, 0, vertices16.size() / 6);
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.35f, 0.0f, 0.0f));
        translationBackMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(-0.35f, 0.0f, 0.0f));
        meshModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix;
        meshModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * meshModel;
        meshShader.setMat4("uM", meshModel);
        glBindVertexArray(VAO[15]);
        glDrawArrays(GL_TRIANGLES, 0, vertices16.size() / 6);

        // AM
        amShader.use();
        amModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        amShader.setMat4("uM", amModel);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture1);
        glBindVertexArray(VAO[16]);
        glDrawArrays(GL_TRIANGLES, 0, 6);
        glBindTexture(GL_TEXTURE_2D, 0);

        // FM
        fmShader.use();
        fmModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        fmShader.setMat4("uM", fmModel);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture2);
        glBindVertexArray(VAO[17]);
        glDrawArrays(GL_TRIANGLES, 0, 6);

        // FM
        volumeShader.use();
        volumeModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        volumeShader.setMat4("uM", volumeModel);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture3);
        glBindVertexArray(VAO[18]);
        glDrawArrays(GL_TRIANGLES, 0, 6);

        // INSTRUCTIONS
        instructionsShader.use();
        instructionsModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        instructionsShader.setMat4("uM", instructionsModel);
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture4);
        glBindVertexArray(VAO[19]);
        glDrawArrays(GL_TRIANGLES, 0, 6);

        // SIGNATURE
        signatureShader.use();
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, texture5);
        glBindVertexArray(VAO[20]);
        glDrawArrays(GL_TRIANGLES, 0, 6);
        glBindTexture(GL_TEXTURE_2D, 0);

        // ONOFF LIGHT 
        onoffLightShader.use();
        if (isOn)
        {
            onoffLightShader.setVec3("mKE", 0.0, 1.0, 0.0);
            onoffLightShader.setFloat("mShine", 0.4 * 128);
            onoffLightShader.setVec3("mKA", 0.0, 0.5, 0.0);
            onoffLightShader.setVec3("mKD", 0.0, 0.5, 0.0);
            onoffLightShader.setVec3("mKS", 0.0, 0.5, 0.0);
        }
        else {
            onoffLightShader.setVec3("mKE", 0.0, 0.0, 0.0);
            onoffLightShader.setFloat("mShine", 0.4 * 128);
            onoffLightShader.setVec3("mKA", 0.1, 0.1, 0.1);
            onoffLightShader.setVec3("mKD", 0.2, 0.2, 0.2);
            onoffLightShader.setVec3("mKS", 0.05, 0.05, 0.05);
        }
        onoffLightModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ;
        onoffLightShader.setMat4("uM", onoffLightModel);
        glBindVertexArray(VAO[21]);
        glDrawArrays(GL_TRIANGLES, 0, 30);

        // ANTENNA LIGHT 
        antennaLightShader.use();
        if (isOn)
        {
            antennaLightShader.setVec3("mKE", 1.0, 1.0, 1.0);
            antennaLightShader.setFloat("mShine", 0.4 * 128);
            antennaLightShader.setVec3("mKA", 0.5, 0.5, 0.5);
            antennaLightShader.setVec3("mKD", 0.5, 0.5, 0.5);
            antennaLightShader.setVec3("mKS", 0.5, 0.5, 0.5);
        }
        else {
            antennaLightShader.setVec3("mKE", 0.0, 0.0, 0.0);
            antennaLightShader.setFloat("mShine", 0.4 * 128);
            antennaLightShader.setVec3("mKA", 0.1, 0.1, 0.1);
            antennaLightShader.setVec3("mKD", 0.2, 0.2, 0.2);
            antennaLightShader.setVec3("mKS", 0.05, 0.05, 0.05);
        }
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(antennaTopRotation), glm::vec3(1.0f, 0.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -antennaTopRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), antennaTopRotationPoint);
        antennaLightModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix;
        rotationMatrix = glm::rotate(glm::mat4(1.0f), glm::radians(antennaRotation), glm::vec3(0.0f, 1.0f, 0.0f));
        translationToOriginMatrix = glm::translate(glm::mat4(1.0f), -antennaRotationPoint);
        translationBackMatrix = glm::translate(glm::mat4(1.0f), antennaRotationPoint);
        antennaLightModel = translationBackMatrix * rotationMatrix * translationToOriginMatrix * antennaLightModel;
        translationMatrix = glm::translate(glm::mat4(1.0f), glm::vec3(0.0f, antennaTranslation, 0.0f));
        antennaLightModel = translationMatrix * antennaLightModel;
        antennaLightModel = modelRotationMatrixX * modelRotationMatrixY * modelRotationMatrixZ * antennaLightModel;
        antennaLightShader.setMat4("uM", antennaLightModel);
        glBindVertexArray(VAO[22]);
        glDrawArrays(GL_TRIANGLES, 0, 30);

        glBindVertexArray(0);
        glUseProgram(0);
        glfwSwapBuffers(window);
        glfwPollEvents();
    }

    glDeleteBuffers(VAOVBOCount, VBO);
    glDeleteVertexArrays(VAOVBOCount, VAO);

    glfwTerminate();
    return 0;
}

static void keyCallback(GLFWwindow* window, int key, int scancode, int action, int mode) {
    if (action == GLFW_RELEASE) return;
    bool isDown = action == GLFW_PRESS;
    switch (key) {
        case GLFW_KEY_ESCAPE:
            glfwSetWindowShouldClose(window, GL_TRUE);
            break;
        case GLFW_KEY_1:
            glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
            glEnable(GL_PROGRAM_POINT_SIZE);
            glPointSize(5);
            break;
        case GLFW_KEY_2:
            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
            break;
        case GLFW_KEY_3:
            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
            break;
        case GLFW_KEY_6:
            glEnable(GL_DEPTH_TEST);
            break;
        case GLFW_KEY_7:
            glDisable(GL_DEPTH_TEST);
            break;
        case GLFW_KEY_8:
            glEnable(GL_CULL_FACE);
            glCullFace(GL_BACK);
            break;
        case GLFW_KEY_9:
            glDisable(GL_CULL_FACE);
            break;
        case GLFW_KEY_4:
            projection = projectionP;
            break;
        case GLFW_KEY_5:
            projection = projectionO;
            break;
        case GLFW_KEY_M:
            resetAntenna = true;
            break;
        case GLFW_KEY_F:
            switchRegime = switchRegime == 0 && amfmSwitchTranslation == 0.0f ? 2 : 1;
            break;
        case GLFW_KEY_ENTER:
            switchPower = switchPower == 0 && onoffSwitchTranslation == 0.0f ? 2 : 1;
            break;
    }
}

static void generateCylinderVertices(float radius, float height, int sides, std::vector<float>& vertices) {
    vertices.clear();

    for (int i = 0; i < sides; ++i) {
        float theta1 = static_cast<float>(i) / sides * 2.0f * M_PI;
        float theta2 = static_cast<float>(i + 1) / sides * 2.0f * M_PI;

        vertices.push_back(radius * std::cos(theta1));
        vertices.push_back(0.5f * height);            
        vertices.push_back(radius * std::sin(theta1));  
        vertices.push_back(std::cos(theta1));           
        vertices.push_back(0.0f);                      
        vertices.push_back(std::sin(theta1));           

        vertices.push_back(radius * std::cos(theta2));
        vertices.push_back(0.5f * height);             
        vertices.push_back(radius * std::sin(theta2)); 
        vertices.push_back(std::cos(theta2));           
        vertices.push_back(0.0f);                      
        vertices.push_back(std::sin(theta2));         

        vertices.push_back(radius * std::cos(theta1));  
        vertices.push_back(-0.5f * height);            
        vertices.push_back(radius * std::sin(theta1)); 
        vertices.push_back(std::cos(theta1));          
        vertices.push_back(0.0f);                      
        vertices.push_back(std::sin(theta1));           

        // ---------------------------------------------
        vertices.push_back(radius * std::cos(theta1));
        vertices.push_back(-0.5f * height);          
        vertices.push_back(radius * std::sin(theta1)); 
        vertices.push_back(std::cos(theta1));      
        vertices.push_back(0.0f);                      
        vertices.push_back(std::sin(theta1));        

        vertices.push_back(radius * std::cos(theta2)); 
        vertices.push_back(0.5f * height);            
        vertices.push_back(radius * std::sin(theta2)); 
        vertices.push_back(std::cos(theta2));        
        vertices.push_back(0.0f);                   
        vertices.push_back(std::sin(theta2));         

        vertices.push_back(radius * std::cos(theta2));
        vertices.push_back(-0.5f * height);           
        vertices.push_back(radius * std::sin(theta2)); 
        vertices.push_back(std::cos(theta2));        
        vertices.push_back(0.0f);                      
        vertices.push_back(std::sin(theta2));        
    }

    for (int i = 0; i < sides; ++i) {
        float theta1 = static_cast<float>(i) / sides * 2.0f * M_PI;
        float theta2 = static_cast<float>(i + 1) / sides * 2.0f * M_PI;

        vertices.push_back(radius * std::cos(theta1));
        vertices.push_back(0.5f * height);           
        vertices.push_back(radius * std::sin(theta1)); 
        vertices.push_back(0.0f);                    
        vertices.push_back(1.0f);                    
        vertices.push_back(0.0f);                     

        vertices.push_back(0.0f);                   
        vertices.push_back(0.5f * height);            
        vertices.push_back(0.0f);                   
        vertices.push_back(0.0f);                     
        vertices.push_back(1.0f);                      
        vertices.push_back(0.0f);                 

        vertices.push_back(radius * std::cos(theta2)); 
        vertices.push_back(0.5f * height);            
        vertices.push_back(radius * std::sin(theta2));  
        vertices.push_back(0.0f);                  
        vertices.push_back(1.0f);                
        vertices.push_back(0.0f);

        // ---------------------------------------------
        vertices.push_back(radius * std::cos(theta1)); 
        vertices.push_back(-0.5f * height);           
        vertices.push_back(radius * std::sin(theta1)); 
        vertices.push_back(0.0f);                     
        vertices.push_back(-1.0f);                      
        vertices.push_back(0.0f);                    

        vertices.push_back(radius * std::cos(theta2));
        vertices.push_back(-0.5f * height);           
        vertices.push_back(radius * std::sin(theta2)); 
        vertices.push_back(0.0f);                     
        vertices.push_back(-1.0f);                    
        vertices.push_back(0.0f);                      

        vertices.push_back(0.0f);                     
        vertices.push_back(-0.5f * height);           
        vertices.push_back(0.0f);                      
        vertices.push_back(0.0f);                     
        vertices.push_back(-1.0f);                   
        vertices.push_back(0.0f);                    
    }
}

static void generateConeVertices(float radius, float height, int sides, std::vector<float>& vertices) {
    vertices.clear();

    for (int i = 0; i < sides; ++i) {
        float theta1 = static_cast<float>(i) / sides * 2.0f * M_PI;
        float theta2 = static_cast<float>(i + 1) / sides * 2.0f * M_PI;

        vertices.push_back(radius * std::cos(theta1));
        vertices.push_back(height);                 
        vertices.push_back(radius * std::sin(theta1));
        vertices.push_back(-std::cos(theta1));     
        vertices.push_back(0.0f);                    
        vertices.push_back(-std::sin(theta1));         

        vertices.push_back(0.0f);                    
        vertices.push_back(0.0f);         
        vertices.push_back(0.0f);                 
        vertices.push_back(0.0f);                  
        vertices.push_back(1.0f);                 
        vertices.push_back(0.0f);               

        vertices.push_back(radius * std::cos(theta2));  
        vertices.push_back(height);                   
        vertices.push_back(radius * std::sin(theta2));  
        vertices.push_back(-std::cos(theta2));      
        vertices.push_back(0.0f);                 
        vertices.push_back(-std::sin(theta2));     
    }
}

static void generateMeshVertices(std::vector<float>& vertices) {
    vertices.clear();

    float x1 = -0.6f;
    float x2 = -0.1f;
    float y1 = -0.25f;
    float y2 = -0.25f + 0.0025f;
    float z1 = 0.395f;
    float z2 = 0.3925f;

    while (y1 < 0.24f) {
        y1 += 0.01f;
        float y2 = y1 + 0.0025f;

        vertices.push_back(x1);
        vertices.push_back(y1);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);

        vertices.push_back(x2);
        vertices.push_back(y1);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);

        vertices.push_back(x2);
        vertices.push_back(y2);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);

        vertices.push_back(x2);
        vertices.push_back(y2);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);

        vertices.push_back(x1);
        vertices.push_back(y2);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);

        vertices.push_back(x1);
        vertices.push_back(y1);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);

        // ---------------------------------------------
        vertices.push_back(x2);
        vertices.push_back(y1);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);

        vertices.push_back(x1);
        vertices.push_back(y1);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);

        vertices.push_back(x1);
        vertices.push_back(y2);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);

        vertices.push_back(x1);
        vertices.push_back(y2);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);

        vertices.push_back(x2);
        vertices.push_back(y2);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);

        vertices.push_back(x2);
        vertices.push_back(y1);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);

        // ---------------------------------------------
        vertices.push_back(x1);
        vertices.push_back(y1);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x2);
        vertices.push_back(y1);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x2);
        vertices.push_back(y1);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x2);
        vertices.push_back(y1);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x1);
        vertices.push_back(y1);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x1);
        vertices.push_back(y1);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(-1.0f);
        vertices.push_back(0.0f);

        // ---------------------------------------------
        vertices.push_back(x1);
        vertices.push_back(y2);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x2);
        vertices.push_back(y2);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x2);
        vertices.push_back(y2);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x2);
        vertices.push_back(y2);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x1);
        vertices.push_back(y2);
        vertices.push_back(z2);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        vertices.push_back(0.0f);

        vertices.push_back(x1);
        vertices.push_back(y2);
        vertices.push_back(z1);
        vertices.push_back(0.0f);
        vertices.push_back(1.0f);
        vertices.push_back(0.0f);
    }
}

static unsigned loadImageToTexture(const char* filePath) {
    int TextureWidth;
    int TextureHeight;
    int TextureChannels;
    unsigned char* ImageData = stbi_load(filePath, &TextureWidth, &TextureHeight, &TextureChannels, 0);
    if (ImageData != NULL)
    {
        stbi__vertical_flip(ImageData, TextureWidth, TextureHeight, TextureChannels);

        GLint InternalFormat = -1;
        switch (TextureChannels) {
        case 1: InternalFormat = GL_RED; break;
        case 3: InternalFormat = GL_RGB; break;
        case 4: InternalFormat = GL_RGBA; break;
        default: InternalFormat = GL_RGB; break;
        }

        unsigned int Texture;
        glGenTextures(1, &Texture);
        glBindTexture(GL_TEXTURE_2D, Texture);
        glTexImage2D(GL_TEXTURE_2D, 0, InternalFormat, TextureWidth, TextureHeight, 0, InternalFormat, GL_UNSIGNED_BYTE, ImageData);
        glBindTexture(GL_TEXTURE_2D, 0);
        stbi_image_free(ImageData);
        return Texture;
    }
    else
    {
        std::cout << "Texture couldn't be loaded! Texture path: " << filePath << std::endl;
        stbi_image_free(ImageData);
        return 0;
    }
}